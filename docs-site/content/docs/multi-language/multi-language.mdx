---
title: Multi-Language Support
description: Use HORUS with Python, C, and Rust
order: 19
---

# Multi-Language Support

HORUS supports multiple programming languages, allowing you to choose the best tool for each component of your robotics system.

## Supported Languages

### Rust (Native)

**Best for:** High-performance nodes, control loops, real-time systems

HORUS is written in Rust and provides the most complete API. All examples in the documentation use Rust by default.

**Getting Started:**
```bash
horus new my-project
# Select: Rust (option 2)
```

**Learn more:** [Quick Start](/getting-started/quick-start)

### Python

> **-Production-Ready**: Full-featured Python API with advanced capabilities

**Best for:** Rapid prototyping, AI/ML integration, data processing, visualization

Python bindings provide a simple, Pythonic API for HORUS with production-grade features:
- **Per-node rate control** - Different rates for different nodes (100Hz sensor, 10Hz logger)
- **Automatic timestamps** - Built-in message timing and staleness detection
- **Typed messages** - Optional type-safe messages from Rust (CmdVel, ImuMsg)
- **Multiprocess support** - Process isolation and multi-language systems

Perfect for integrating with NumPy, PyTorch, TensorFlow, and other Python libraries.

**Getting Started:**
```bash
horus new my-project
# Select: Python (option 1)
```

**Learn more:** [Python Bindings](/multi-language/python-bindings)

### C++ (Alpha)

**Best for:** Hardware drivers, legacy system integration, embedded systems

C++ bindings provide low-level access to HORUS with modern RAII-based memory management. Currently in alpha with basic pub/sub support.

**Status:** Alpha - Basic functionality only

**Learn more:** [C++ Bindings](/multi-language/cpp-bindings)

## Cross-Language Communication

**All languages can communicate seamlessly** through HORUS's shared memory system.

### Simple Types (Numbers, Strings)

```python
# Python publisher
import horus
node = horus.Node(name="sensor", pubs="temperature")
node.send("temperature", 25.5)
```

```rust
// Rust subscriber (in another process)
let hub = Hub::<f32>::new("temperature")?;
if let Some(temp) = hub.recv(None) {
    println!("Temperature: {}", temp);
}
```

### Structured Messages - Typed Hubs for Cross-Language Communication

**Important**: For cross-language communication with structured data, you MUST use typed hubs. Generic Python `Hub` uses pickle serialization which Rust cannot deserialize.

#### Python ↔ Rust with Typed Hubs

```python
# Python publisher (pose_publisher.py)
from horus._horus import PyPose2DHub  # Typed hub from Rust bindings
from horus import Pose2D       # Message class

# Create typed hub
hub = PyPose2DHub("robot_pose")

while True:
    # Create and send Pose2D message
    pose = Pose2D(x=1.0, y=2.0, theta=0.5)
    hub.send(pose)
    time.sleep(0.1)
```

```rust
// Rust subscriber (in another process)
use horus::prelude::*;
use horus_library::messages::geometry::Pose2D;

let hub = Hub::<Pose2D>::new("robot_pose")?;
if let Some(pose) = hub.recv(None) {
    println!("Received: x={}, y={}, theta={}", pose.x, pose.y, pose.theta);
}
```

#### Available Typed Hubs

HORUS provides three typed hubs for cross-language communication:

| Python Hub Class | Message Class | Rust Type | Use Case |
|-----------------|---------------|-----------|----------|
| `PyPose2DHub` | `horus.library.Pose2D` | `geometry::Pose2D` | 2D robot position |
| `PyCmdVelHub` | `horus.library.CmdVel` | `cmd_vel::CmdVel` | Velocity commands |
| `PyLaserScanHub` | `horus.library.LaserScan` | `sensor::LaserScan` | 360° LIDAR scans |

**Usage Pattern:**

```python
# Import typed hub from horus._horus
from horus._horus import PyPose2DHub, PyCmdVelHub, PyLaserScanHub

# Import message classes from horus.library
from horus import Pose2D, CmdVel, LaserScan

# Create hub and send messages
pose_hub = PyPose2DHub("robot_pose")
pose_hub.send(Pose2D(x=1.0, y=2.0, theta=0.5))

cmd_hub = PyCmdVelHub("cmd_vel")
cmd_hub.send(CmdVel(linear=1.0, angular=0.5))

scan_hub = PyLaserScanHub("lidar")
scan = LaserScan()
scan.ranges = [1.0] * 360  # Must be exactly 360 elements
scan_hub.send(scan)
```

#### Python-Only Communication (No Rust Interop)

For Python-to-Python communication, you can use the generic `Hub`:

```python
# Generic Hub - Python objects only (uses pickle)
from horus import Hub

hub = Hub("my_topic")
hub.send({"any": "python", "object": [1, 2, 3]})  # Dicts, lists, any Python type
hub.send(MyCustomClass())  # Any Python class

#  This will NOT work with Rust - Rust cannot deserialize pickle!
```

**When to use which:**
- **Typed Hubs** (`PyPose2DHub`, etc.) - When communicating with Rust or C++ nodes
- **Generic Hub** - For Python-only systems with any Python object type

## Choosing a Language

| Use Case | Recommended Language |
|----------|---------------------|
| **Control loops** | Rust (lowest latency) |
| **AI/ML models** | Python (ecosystem) |
| **Hardware drivers** | C++ or Rust |
| **Data processing** | Python or Rust |
| **Real-time systems** | Rust |
| **Prototyping** | Python (fastest development) |

## Mixed-Language Systems

You can build systems with nodes in different languages:

**Example: Robot with mixed languages**
- **Motor controller** (Rust) - 1kHz control loop
- **Vision processing** (Python) - PyTorch object detection
- **Hardware driver** (C++) - Legacy sensor integration
- **Dashboard** (Rust) - Real-time visualization

All communicate through HORUS shared memory with **sub-microsecond latency**.

### Running Mixed-Language Systems

The `horus run` command automatically handles compilation and execution of mixed-language systems:

```bash
# Mix Python and Rust nodes
horus run sensor.py controller.rs visualizer.py

# Mix all three languages
horus run lidar_driver.cpp planner.py motor_control.rs
```

**What happens:**
1. **Rust files** (`.rs`) are automatically compiled with `cargo build` using HORUS dependencies
2. **Python files** (`.py`) are executed directly with Python 3
3. **C++ files** (`.cpp`) are compiled with `g++` linking to HORUS C++ bindings
4. All processes communicate via shared memory at `/dev/shm/horus/`
5. `horus run` manages the lifecycle (start, monitor, stop all together)

**Note:** For Rust files, `horus run` creates a temporary Cargo project in `.horus/` with proper dependencies, builds it with `cargo build`, and executes the resulting binary.

**Example - Complete Mixed System:**

```bash
# sensor.py - Python sensor node
import horus
from horus._horus import PyLaserScanHub
from horus import LaserScan

# Create Hub once outside tick function
hub = PyLaserScanHub("lidar")

def tick(node):
    scan = LaserScan()
    scan.ranges = read_lidar()  # Your hardware driver
    hub.send(scan)

node = horus.Node(name="lidar_sensor", tick=tick, rate=10)
horus.run(node)
```

```rust
// planner.rs - Rust planning node
use horus::prelude::*;
use horus_library::messages::{sensor::LaserScan, cmd_vel::CmdVel};

fn main() -> Result<()> {
    let scan_hub = Hub::<LaserScan>::new("lidar")?;
    let cmd_hub = Hub::<CmdVel>::new("cmd_vel")?;

    loop {
        if let Some(scan) = scan_hub.recv(None) {
            let cmd = plan_path(&scan);  // Your planning logic
            cmd_hub.send(cmd, None)?;
        }
    }
}
```

```bash
# Run both together
horus run sensor.py planner.rs

# Both processes communicate seamlessly via shared memory!
```

**Benefits:**
- **No manual compilation** - `horus run` handles it
- **Automatic dependency management** - HORUS libraries linked correctly
- **Process isolation** - One crash doesn't kill the whole system
- **True parallelism** - Each process can use separate CPU cores
- **Hot reload** - Change a file, stop/restart just that node

## Next Steps

**Choose your language:**
- [Python Bindings](/multi-language/python-bindings) - Full guide with examples
- [C++ Bindings](/multi-language/cpp-bindings) - Alpha status, basic usage
- [Quick Start](/getting-started/quick-start) - Get started with Rust

**Build something:**
- [Examples](/examples) - See multi-language systems in action
- [CLI Reference](/development/cli-reference) - `horus new` command options
