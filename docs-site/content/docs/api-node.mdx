---
title: Node API Reference
description: Complete API reference for the Node trait
order: 413
---

# Node API Reference

The `Node` trait is the core abstraction in HORUS. Implement this trait to create custom nodes.

## The Node Trait

```rust
pub trait Node: Send {
    fn name(&self) -> &'static str;
    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()>;
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>);
    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()>;
}
```

## Required Methods

### `name()`

Returns the unique name of the node.

```rust
fn name(&self) -> &'static str;
```

**Returns**: A static string slice containing the node's name.

**Example**:
```rust
impl Node for MyNode {
    fn name(&self) -> &'static str {
        "MyNode"
    }
}
```

### `tick()`

Main execution loop called repeatedly by the scheduler (default ~60 FPS).

```rust
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>);
```

**Parameters**:
- `ctx`: Optional mutable reference to `NodeInfo` for logging and metrics

**Example**:
```rust
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    let data = self.read_sensor();
    self.publisher.send(data, ctx).ok();
}
```

**Best Practices**:
- Keep tick() fast - it runs 60 times per second
- Avoid blocking operations
- Use non-blocking I/O when possible
- Don't allocate large objects every tick

## Optional Methods

### `init()`

Called once when the node is added to the scheduler. Use for setup and initialization.

```rust
fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {
    ctx.log_info("Node initialized");
    Ok(())
}
```

**Parameters**:
- `ctx`: Mutable reference to `NodeInfo` for logging

**Returns**: `Ok(())` on success, `Err(String)` with error message on failure

**Example**:
```rust
fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {
    self.connection = Some(connect_to_device()?);
    ctx.log_info("Connected to device");
    Ok(())
}
```

### `shutdown()`

Called once when the scheduler stops. Use for cleanup.

```rust
fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {
    ctx.log_info("Node shutdown");
    Ok(())
}
```

**Parameters**:
- `ctx`: Mutable reference to `NodeInfo` for logging

**Returns**: `Ok(())` on success, `Err(String)` with error message on failure

**Example**:
```rust
fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {
    if let Some(conn) = self.connection.take() {
        conn.disconnect()?;
    }
    ctx.log_info("Disconnected from device");
    Ok(())
}
```

### `get_publishers()`

Returns list of topics this node publishes to.

```rust
fn get_publishers(&self) -> Vec<TopicMetadata> {
    Vec::new()
}
```

**Returns**: Vector of `TopicMetadata` describing published topics

**Example**:
```rust
fn get_publishers(&self) -> Vec<TopicMetadata> {
    vec![
        TopicMetadata {
            topic_name: "cmd_vel".to_string(),
            type_name: "f32".to_string(),
        }
    ]
}
```

### `get_subscribers()`

Returns list of topics this node subscribes to.

```rust
fn get_subscribers(&self) -> Vec<TopicMetadata> {
    Vec::new()
}
```

**Returns**: Vector of `TopicMetadata` describing subscribed topics

**Example**:
```rust
fn get_subscribers(&self) -> Vec<TopicMetadata> {
    vec![
        TopicMetadata {
            topic_name: "sensor_data".to_string(),
            type_name: "f32".to_string(),
        }
    ]
}
```

### `on_error()`

Called when an error occurs. Override for custom error handling.

```rust
fn on_error(&mut self, error: &str, ctx: &mut NodeInfo) {
    ctx.log_error(&format!("Node error: {}", error));
}
```

**Parameters**:
- `error`: Error message string
- `ctx`: Mutable reference to `NodeInfo` for logging

### `priority()`

Returns the execution priority for this node.

```rust
fn priority(&self) -> NodePriority {
    NodePriority::Normal
}
```

**Returns**: `NodePriority` enum value (Critical=0, High=1, Normal=2, Low=3, Background=4)

### `is_healthy()`

Health check called by monitoring systems.

```rust
fn is_healthy(&self) -> bool {
    true
}
```

**Returns**: `true` if node is healthy, `false` otherwise

## NodeInfo Context

The `NodeInfo` context provides logging and metrics tracking.

### Logging Methods

```rust
ctx.log_info("Informational message");
ctx.log_warning("Warning message");
ctx.log_error("Error message");
ctx.log_debug("Debug message");
```

### Pub/Sub Logging

**Do not call these directly** - they are called automatically by `Hub::send()` and `Hub::recv()`:

```rust
// Called automatically by Hub::send()
ctx.log_pub(&topic, &data, ipc_ns);

// Called automatically by Hub::recv()
ctx.log_sub(&topic, &data, ipc_ns);
```

### Accessing Metrics

```rust
let metrics = ctx.metrics();
println!("Total ticks: {}", metrics.total_ticks);
println!("Average tick duration: {}ms", metrics.avg_tick_duration_ms);
```

## Complete Example

```rust
use horus::prelude::*;

struct TemperatureSensor {
    temperature_pub: Hub<f32>,
    reading: f32,
}

impl TemperatureSensor {
    fn new() -> Result<Self> {
        Ok(Self {
            temperature_pub: Hub::new("temperature")?,
            reading: 20.0,
        })
    }
}

impl Node for TemperatureSensor {
    fn name(&self) -> &'static str {
        "TemperatureSensor"
    }

    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {
        ctx.log_info("Temperature sensor initialized");
        Ok(())
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Simulate reading
        self.reading += 0.1;

        // Publish temperature
        self.temperature_pub.send(self.reading, ctx).ok();
    }

    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {
        ctx.log_info("Temperature sensor shutdown");
        Ok(())
    }
}
```

## Handling Context with Multiple Calls

### Understanding `mut ctx`

When using `ctx.log_debug()` and similar methods (provided by NodeInfoExt), you need to declare `ctx` as mutable:

```rust
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    // ^^^ mut required for ctx.log_debug() to work
    if let Some(input) = self.keyboard_sub.recv(None) {
        ctx.log_debug(&format!("Key pressed: {}", input.code));

        let state = process(input);
        self.state_pub.send(state, ctx).ok();
    }
}
```

**Why `mut` is required:**
- `ctx.log_debug()` is provided by the NodeInfoExt trait
- These methods take `&mut self`, requiring `ctx` to be mutable
- This is true even if you pass `None` to `recv()`

### Common Patterns

**Pattern 1: Logging and Pub/Sub** (Recommended)
```rust
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    if let Some(data) = self.input_sub.recv(None) {
        ctx.log_debug("Processing");
        let output = process(data);
        self.output_pub.send(output, ctx).ok();
    }
}
```

**Pattern 2: Just Publishing** (No recv logging)
```rust
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    let reading = self.read_sensor();
    self.publisher.send(reading, ctx).ok();
}
```

**Pattern 3: No Logging** (Maximum Performance)
```rust
fn tick(&mut self, _ctx: Option<&mut NodeInfo>) {
    if let Some(data) = self.input_sub.recv(None) {
        let output = self.process(data);
        self.output_pub.send(output, None).ok();
    }
}
```

### Advanced: Logging Both Recv and Send

Only use this if you specifically need `ctx` logging for **both** `recv()` and `send()`:

```rust
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    //                ^^^ mut required for reborrowing

    // Reborrow for recv
    if let Some(input) = self.input_sub.recv(ctx.as_deref_mut()) {
        ctx.log_debug("Processing");

        // Reborrow for send
        self.output_pub.send(output, ctx.as_deref_mut()).ok();
    }
}
```

**When to use:**
- You need detailed IPC timing logs for both recv and send
- Debugging performance issues
- Profiling node communication

**Cost:**
- More complex code
- Requires understanding `as_deref_mut()` reborrowing

### Best Practices

- **Recommended**: Use `mut ctx` + pass `None` to `recv()` + use `ctx` for logging and `send()`
- **Performance**: Pass `_ctx` (unused) and `None` to both `recv()` and `send()` if you don't need logs
- **Advanced**: Use `ctx.as_deref_mut()` for both `recv()` and `send()` when you need IPC timing logs for both
- **Wrong**: Don't pass `ctx` to multiple calls without reborrowing via `as_deref_mut()`

## Node Lifecycle

Every node follows this lifecycle:

1. **Created** - Node struct is instantiated
2. **Added** - Added to scheduler via `scheduler.add()`
3. **Initialized** - `init()` called once
4. **Running** - `tick()` called repeatedly (~60 FPS)
5. **Stopping** - `shutdown()` called once
6. **Stopped** - Node removed from scheduler

## Node States

Nodes can be in these states (managed automatically by scheduler):

- `Uninitialized` - Just created, not yet initialized
- `Initializing` - Running init()
- `Running` - Normal operation in tick() loop
- `Paused` - Temporarily suspended (future feature)
- `Stopping` - Running shutdown()
- `Stopped` - Clean shutdown complete
- `Error(msg)` - Recoverable error state
- `Crashed(msg)` - Unrecoverable error

## Priority Levels

```rust
pub enum NodePriority {
    Critical = 0,    // Highest priority
    High = 1,
    Normal = 2,      // Default
    Low = 3,
    Background = 4,  // Lowest priority
}
```

Nodes execute in priority order each tick. Use priorities to ensure critical nodes run first.

## See Also

- [Hub API Reference](/api-hub) - Pub/sub communication
- [Scheduler API Reference](/api-scheduler) - Node orchestration
- [Core Concepts: Nodes](/core-concepts-nodes) - Detailed guide
