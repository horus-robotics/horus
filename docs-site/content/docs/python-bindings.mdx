---
title: Python Bindings
description: Production-ready Python API for HORUS robotics with advanced features
order: 14
---

# HORUS Python Bindings

**Production-Ready Python API** for the HORUS robotics framework - combines simplicity with advanced features for professional robotics applications.

## Why HORUS Python?

- **Zero Boilerplate**: Working node in 10 lines
- **Functional API**: No class inheritance required
- **Production Performance**: ~500ns latency (same shared memory as Rust)
- **Per-Node Rate Control**: Different nodes at different frequencies (100Hz sensor, 10Hz logger)
- **Automatic Timestamps**: Built-in message timing and staleness detection
- **Typed Messages**: Optional type-safe messages from Rust
- **Multiprocess Support**: Process isolation and multi-language nodes
- **Pythonic**: Feels like native Python, not wrapped C++
- **Rich Ecosystem**: Use NumPy, OpenCV, scikit-learn, etc.

---

## Quick Start

### Installation

**Automatic (Recommended)**

Python bindings are automatically installed when you run the HORUS installer:

```bash
# From HORUS root directory
./install.sh
```

The installer will detect Python 3.9+ and automatically build and install the bindings.

**Manual Installation**

If you prefer to install manually or need to rebuild:

```bash
# Install maturin (Python/Rust build tool)
pip install maturin

# Build and install from source
cd horus_py
maturin develop --release
```

**Requirements**:
- Python 3.9+
- Rust 1.70+
- Linux (for shared memory support)

### Minimal Example

```python
import horus

def process(node):
    node.send("output", "Hello HORUS!")

node = horus.Node(pubs="output", tick=process, rate=1)
horus.run(node, duration=3)
```

**That's it!** No classes, no boilerplate, just pure logic.

---

## Core API

### Creating a Node

```python
node = horus.Node(
    name="my_node",            # Optional: auto-generated if not provided
    pubs=["topic1", "topic2"], # Topics to publish to
    subs=["input1", "input2"], # Topics to subscribe to
    tick=my_function,          # Function called repeatedly
    rate=30,                   # Hz (default: 30)
    init=setup_fn,             # Optional: called once at start
    shutdown=cleanup_fn        # Optional: called once at end
)
```

**Parameters**:
- `name` (str, optional): Node name (auto-generated if omitted)
- `pubs` (str | list[str], optional): Topics to publish to
- `subs` (str | list[str], optional): Topics to subscribe from
- `tick` (callable): Function called each cycle
- `rate` (int, optional): Execution rate in Hz (default: 30)
- `init` (callable, optional): Setup function
- `shutdown` (callable, optional): Cleanup function

### Node Functions

Your tick function receives the node as a parameter:

```python
def my_tick(node):
    # Check for messages
    if node.has_msg("input"):
        data = node.get("input")  # Get one message

    # Get all messages
    all_msgs = node.get_all("input")

    # Send messages
    node.send("output", {"value": 42})
```

**Node Methods**:
- `node.send(topic, data)` - Publish message
- `node.get(topic)` - Get one message (returns None if empty)
- `node.get_all(topic)` - Get all messages as list
- `node.has_msg(topic)` - Check if messages available

### Running Nodes

```python
# Single node
horus.run(node)

# Multiple nodes
horus.run(node1, node2, node3, duration=10)
```

---

## Examples

### 1. Simple Publisher

```python
import horus

def publish_temperature(node):
    node.send("temperature", 25.5)

sensor = horus.Node(
    name="temp_sensor",
    pubs="temperature",
    tick=publish_temperature,
    rate=1  # 1 Hz
)

horus.run(sensor, duration=10)
```

### 2. Subscriber

```python
import horus

def display_temperature(node):
    if node.has_msg("temperature"):
        temp = node.get("temperature")
        print(f"Temperature: {temp}Â°C")

display = horus.Node(
    name="display",
    subs="temperature",
    tick=display_temperature
)

horus.run(display)
```

### 3. Pub/Sub Pipeline

```python
import horus

def publish(node):
    node.send("raw", 42.0)

def process(node):
    if node.has_msg("raw"):
        data = node.get("raw")
        result = data * 2.0
        node.send("processed", result)

def display(node):
    if node.has_msg("processed"):
        value = node.get("processed")
        print(f"Result: {value}")

# Create pipeline
publisher = horus.Node("publisher", pubs="raw", tick=publish, rate=1)
processor = horus.Node("processor", subs="raw", pubs="processed", tick=process)
displayer = horus.Node("display", subs="processed", tick=display)

# Run all together
horus.run(publisher, processor, displayer, duration=5)
```

### 4. Using Lambda Functions

```python
import horus

# Producer (inline)
producer = horus.Node(
    pubs="numbers",
    tick=lambda n: n.send("numbers", 42),
    rate=1
)

# Transformer (inline)
doubler = horus.Node(
    subs="numbers",
    pubs="doubled",
    tick=lambda n: n.send("doubled", n.get("numbers") * 2) if n.has_msg("numbers") else None
)

horus.run(producer, doubler, duration=5)
```

### 5. Multi-Topic Robot Controller

```python
import horus

def robot_controller(node):
    # Read from multiple sensors
    lidar_data = None
    camera_data = None

    if node.has_msg("lidar"):
        lidar_data = node.get("lidar")

    if node.has_msg("camera"):
        camera_data = node.get("camera")

    # Compute commands
    if lidar_data and camera_data:
        cmd = compute_navigation(lidar_data, camera_data)
        node.send("motors", cmd)
        node.send("status", "navigating")

robot = horus.Node(
    name="robot_controller",
    subs=["lidar", "camera"],
    pubs=["motors", "status"],
    tick=robot_controller,
    rate=50  # 50Hz control loop
)
```

### 6. Lifecycle Management

```python
import horus

class Context:
    def __init__(self):
        self.count = 0
        self.file = None

ctx = Context()

def init_handler(node):
    print("Starting up!")
    ctx.file = open("data.txt", "w")

def tick_handler(node):
    ctx.count += 1
    data = f"Tick {ctx.count}"
    node.send("data", data)
    ctx.file.write(data + "\n")

def shutdown_handler(node):
    print(f"Processed {ctx.count} messages")
    ctx.file.close()

node = horus.Node(
    pubs="data",
    init=init_handler,
    tick=tick_handler,
    shutdown=shutdown_handler,
    rate=10
)

horus.run(node, duration=5)
```

---

## Quick Helpers

HORUS Python provides convenience functions for common patterns:

### Transform Node

```python
# One-liner transform
doubler = horus.quick(
    sub="input",
    pub="output",
    fn=lambda x: x * 2
)
horus.run(doubler)
```

### Pipe

```python
# Simple processing pipeline
horus.pipe("input", "output", lambda x: x ** 2)
```

### Echo

```python
# Mirror topic to another
horus.echo("sensor_raw", "sensor_backup")
```

### Filter

```python
# Filter messages
horus.filter_node("all_data", "positive_only", lambda x: x > 0)
```

### Fanout (Broadcast)

```python
# Send to multiple topics
horus.fanout("sensor", ["log", "display", "storage"])
```

### Merge

```python
# Combine multiple inputs
horus.merge(["sensor1", "sensor2", "sensor3"], "all_sensors")
```

---

## Advanced Features (Production-Ready)

HORUS Python includes advanced features that match or exceed ROS2 capabilities while maintaining simplicity.

### Per-Node Rate Control (Phase 1)

Each node can run at its own independent rate, enabling optimal performance for different tasks:

```python
import horus

# Create scheduler with per-node rates
scheduler = horus.Scheduler()

# High-frequency sensor (100Hz)
scheduler.add(sensor_node, priority=0, logging=True, rate_hz=100.0)

# Medium-frequency controller (50Hz)
scheduler.add(control_node, priority=1, logging=False, rate_hz=50.0)

# Low-frequency logger (10Hz)
scheduler.add(logger_node, priority=2, logging=True, rate_hz=10.0)

scheduler.run()
```

**Runtime Rate Adjustment:**

```python
# Change node rate while running
scheduler.set_node_rate("sensor", 200.0)  # Increase to 200Hz

# Get node statistics
stats = scheduler.get_node_stats("sensor")
print(f"Node: {stats['name']}")
print(f"Rate: {stats['rate_hz']}Hz")
print(f"Total ticks: {stats['total_ticks']}")
print(f"Errors: {stats['errors_count']}")
```

**Priority-Based Execution:**

Lower priority numbers execute first, ensuring correct data flow:

```python
scheduler.add(sensor, priority=0)     # Executes FIRST
scheduler.add(controller, priority=1) # Executes SECOND
scheduler.add(actuator, priority=2)   # Executes THIRD
```

### Automatic Timestamps (Phase 2)

All messages automatically get microsecond-precision timestamps:

```python
import horus
import time

def control_tick(node):
    if node.has_msg("sensor_data"):
        # Check message age
        age = node.get_message_age("sensor_data")
        if age > 0.1:  # More than 100ms old
            node.log_warning(f"Stale data: {age*1000:.1f}ms old")
            return

        # Or use built-in staleness detection
        if node.is_stale("sensor_data", max_age=0.1):
            return  # Skip stale data

        # Get message with timestamp
        msg, timestamp = node.get_with_timestamp("sensor_data")
        latency = time.time() - timestamp
        print(f"Latency: {latency*1000:.1f}ms")

        # Process fresh data
        data = node.get("sensor_data")
        process(data)
```

**Timestamp Methods:**

- `node.get_message_age(topic)` - Get age of next message in seconds
- `node.is_stale(topic, max_age)` - Check if message is too old
- `node.get_timestamp(topic)` - Peek at timestamp without consuming
- `node.get_with_timestamp(topic)` - Get message and timestamp together

### Typed Messages (Phase 3)

Use Rust message types for better performance and type safety:

```python
import horus

# Create typed messages
cmd = horus.CmdVel(linear=1.5, angular=0.8)
print(cmd)  # "linear: 1.50 m/s, angular: 0.80 rad/s"

# Messages have automatic timestamps
print(f"Message age: {cmd.age():.3f}s")

# IMU data
imu = horus.ImuMsg(
    accel_x=1.0, accel_y=2.0, accel_z=3.0,
    gyro_x=0.1, gyro_y=0.2, gyro_z=0.3
)

# Send typed messages
node.send("cmd_vel", cmd)
node.send("imu_data", imu)

# Still backward compatible with dicts!
node.send("cmd_vel", {"linear": 1.0, "angular": 0.5})
```

**Available Message Types:**

- `horus.CmdVel(linear, angular)` - Robot velocity commands
- `horus.ImuMsg(accel_x, accel_y, accel_z, gyro_x, gyro_y, gyro_z)` - IMU sensor data

**Message Features:**

```python
cmd = horus.CmdVel(linear=2.0, angular=1.0)

# Access fields
print(cmd.linear, cmd.angular)

# Get timestamp
print(cmd.timestamp)

# Check age
if cmd.age() > 0.1:
    print("Message is stale")

# Convert to dict for compatibility
d = cmd.to_dict()

# Create from dict
cmd2 = horus.CmdVel.from_dict(d)

# Factory methods
stop = horus.CmdVel.zero()  # Create stop command
```

### Multiprocess Execution (Phase 4)

Run Python nodes in separate processes for isolation and multi-language support:

```bash
# Run multiple Python files as separate processes
horus run node1.py node2.py node3.py

# Mix Python and Rust nodes
horus run sensor.rs controller.py visualizer.py

# Mix all languages
horus run lidar_driver.c planner.py motor_control.rs
```

All nodes in the same `horus run` session automatically communicate via shared memory!

**Example - Distributed System:**

```python
# sensor_node.py
import horus

def sensor_tick(node):
    data = read_lidar()  # Your sensor code
    node.send("lidar_data", data)

sensor = horus.Node(name="lidar", pubs="lidar_data", tick=sensor_tick)
horus.run(sensor)
```

```python
# controller_node.py
import horus

def control_tick(node):
    if node.has_msg("lidar_data"):
        data = node.get("lidar_data")
        cmd = compute_control(data)
        node.send("motor_cmd", cmd)

controller = horus.Node(
    name="controller",
    subs="lidar_data",
    pubs="motor_cmd",
    tick=control_tick
)
horus.run(controller)
```

```bash
# Run both in separate processes
horus run sensor_node.py controller_node.py
```

**Benefits:**
- **Process isolation**: One crash doesn't kill everything
- **Multi-language**: Mix Python, Rust, and C nodes seamlessly
- **Parallel execution**: True multicore utilization
- **Zero configuration**: Shared memory IPC automatically set up

### Complete Example: All Features Together

```python
import horus
import time

def sensor_tick(node):
    """High-frequency sensor (100Hz)"""
    imu = horus.ImuMsg(accel_x=1.0, accel_y=0.0, accel_z=9.8)
    node.send("imu_data", imu)
    node.log_info(f"Published IMU (age: {imu.age():.3f}s)")

def control_tick(node):
    """Medium-frequency control (50Hz)"""
    if node.has_msg("imu_data"):
        # Check for stale data
        if node.is_stale("imu_data", max_age=0.05):
            node.log_warning("Stale IMU data!")
            return

        imu = node.get("imu_data")
        cmd = horus.CmdVel(linear=1.0, angular=0.0)
        node.send("cmd_vel", cmd)

def logger_tick(node):
    """Low-frequency logging (10Hz)"""
    if node.has_msg("cmd_vel"):
        msg, timestamp = node.get_with_timestamp("cmd_vel")
        latency = (time.time() - timestamp) * 1000
        node.log_info(f"Command latency: {latency:.1f}ms")

# Create nodes
sensor = horus.Node(name="imu", pubs="imu_data", tick=sensor_tick)
controller = horus.Node(name="ctrl", subs="imu_data", pubs="cmd_vel", tick=control_tick)
logger = horus.Node(name="log", subs="cmd_vel", tick=logger_tick)

# Configure with different rates and priorities
scheduler = horus.Scheduler()
scheduler.add(sensor, priority=0, logging=True, rate_hz=100.0)
scheduler.add(controller, priority=1, logging=False, rate_hz=50.0)
scheduler.add(logger, priority=2, logging=True, rate_hz=10.0)

scheduler.run(duration=5.0)

# Check statistics
stats = scheduler.get_node_stats("imu")
print(f"Sensor: {stats['total_ticks']} ticks in 5 seconds")
```

---

## Integration with Python Ecosystem

### NumPy Integration

```python
import horus
import numpy as np

def process_array(node):
    if node.has_msg("raw_data"):
        data = node.get("raw_data")
        # Convert to NumPy array
        arr = np.array(data)
        # Process with NumPy
        result = np.fft.fft(arr)
        node.send("fft_result", result.tolist())

processor = horus.Node(
    subs="raw_data",
    pubs="fft_result",
    tick=process_array
)
```

### OpenCV Integration

```python
import horus
import cv2
import numpy as np

def process_image(node):
    if node.has_msg("camera"):
        img_data = node.get("camera")
        # Convert to OpenCV format
        img = np.array(img_data, dtype=np.uint8).reshape((480, 640, 3))

        # Apply OpenCV processing
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        edges = cv2.Canny(gray, 50, 150)

        # Publish result
        node.send("edges", edges.flatten().tolist())

vision = horus.Node(
    subs="camera",
    pubs="edges",
    tick=process_image,
    rate=30
)
```

### scikit-learn Integration

```python
import horus
from sklearn.linear_model import LinearRegression
import numpy as np

model = LinearRegression()

def train_model(node):
    if node.has_msg("training_data"):
        data = node.get("training_data")
        X = np.array(data['features'])
        y = np.array(data['labels'])

        # Train model
        model.fit(X, y)
        score = model.score(X, y)

        node.send("model_score", score)

trainer = horus.Node(
    subs="training_data",
    pubs="model_score",
    tick=train_model
)
```

---

## Advanced Patterns

### State Management

```python
import horus

class RobotState:
    def __init__(self):
        self.position = {"x": 0.0, "y": 0.0}
        self.velocity = 0.0
        self.last_update = 0

state = RobotState()

def update_state(node):
    if node.has_msg("velocity"):
        state.velocity = node.get("velocity")

    if node.has_msg("position"):
        state.position = node.get("position")

    # Publish combined state
    node.send("robot_state", {
        "pos": state.position,
        "vel": state.velocity
    })

state_manager = horus.Node(
    subs=["velocity", "position"],
    pubs="robot_state",
    tick=update_state
)
```

### Rate Limiting

```python
import horus
import time

class RateLimiter:
    def __init__(self, min_interval):
        self.min_interval = min_interval
        self.last_send = 0

limiter = RateLimiter(min_interval=0.1)  # 100ms minimum

def rate_limited_publish(node):
    current_time = time.time()

    if current_time - limiter.last_send >= limiter.min_interval:
        node.send("output", "data")
        limiter.last_send = current_time

node = horus.Node(
    pubs="output",
    tick=rate_limited_publish,
    rate=100  # Node runs at 100Hz, but publishes at max 10Hz
)
```

### Error Handling

```python
import horus

def safe_processing(node):
    try:
        if node.has_msg("input"):
            data = node.get("input")
            result = risky_operation(data)
            node.send("output", result)
    except Exception as e:
        node.send("errors", str(e))
        print(f"Error: {e}")

processor = horus.Node(
    subs="input",
    pubs=["output", "errors"],
    tick=safe_processing
)
```

---

## Performance Tips

### 1. Use Per-Node Rate Control

```python
# NEW: Use scheduler with per-node rates for optimal performance
scheduler = horus.Scheduler()

# High-frequency sensor (100Hz)
scheduler.add(sensor, priority=0, rate_hz=100.0)

# Medium-frequency control (50Hz)
scheduler.add(controller, priority=1, rate_hz=50.0)

# Low-frequency logging (10Hz)
scheduler.add(logger, priority=2, rate_hz=10.0)

scheduler.run()

# Monitor performance with get_node_stats()
stats = scheduler.get_node_stats("sensor")
print(f"Sensor executed {stats['total_ticks']} ticks")
```

### 2. Monitor Message Staleness

```python
def control_tick(node):
    # Skip stale data to maintain real-time performance
    if node.is_stale("sensor_data", max_age=0.1):
        node.log_warning("Skipping stale sensor data")
        return

    # Process fresh data only
    data = node.get("sensor_data")
    process(data)
```

### 3. Use Typed Messages

```python
# Typed messages are more efficient than dicts
cmd = horus.CmdVel(linear=1.5, angular=0.8)
node.send("cmd_vel", cmd)

# Check message age efficiently
if cmd.age() > 0.1:
    print("Message is stale")
```

### 4. Batch Processing

```python
def batch_processor(node):
    # Process all available messages at once
    messages = node.get_all("input")
    if messages:
        results = [process(msg) for msg in messages]
        for result in results:
            node.send("output", result)
```

### 5. Keep tick() Fast

```python
# GOOD: Fast tick
def good_tick(node):
    if node.has_msg("input"):
        data = node.get("input")
        result = quick_operation(data)
        node.send("output", result)

# BAD: Slow tick
def bad_tick(node):
    time.sleep(1)  # Don't block!
    data = requests.get("http://api.example.com")  # Don't do I/O!
```

### 6. Offload Heavy Processing

```python
from concurrent.futures import ThreadPoolExecutor

executor = ThreadPoolExecutor(max_workers=4)

def heavy_processing_node(node):
    if node.has_msg("input"):
        data = node.get("input")
        # Offload to thread pool
        future = executor.submit(expensive_operation, data)
        # Don't block - check result later or use callback
```

### 7. Use Multiprocess for CPU-Intensive Tasks

```bash
# Isolate heavy processing in separate processes
horus run sensor.py heavy_vision.py light_controller.py

# Each node gets its own CPU core
```

---

## Development

### Building from Source

```bash
# Debug build (fast compile, slow runtime)
cd horus_py
maturin develop

# Release build (slow compile, fast runtime)
maturin develop --release

# Build wheel for distribution
maturin build --release
```

### Running Tests

```bash
# Install test dependencies
pip install pytest

# Run all tests
pytest tests/

# Run specific feature tests
python3 tests/test_rate_control.py    # Phase 1: Per-node rates
python3 tests/test_timestamps.py      # Phase 2: Timestamps
python3 tests/test_typed_messages.py  # Phase 3: Typed messages

# With coverage
pytest --cov=horus tests/

# Test multiprocess execution (Phase 4)
horus run tests/multiprocess_publisher.py tests/multiprocess_subscriber.py
```

### Mock Mode

HORUS Python includes a mock mode for testing without Rust bindings:

```python
# If Rust bindings aren't available, automatically falls back to mock
# You'll see: "Warning: Rust bindings not available. Running in mock mode."

# Use for unit testing Python logic without HORUS running
```

### Debugging Tips

```python
# Enable logging for specific nodes
scheduler = horus.Scheduler()
scheduler.add(my_node, priority=0, logging=True)  # Enable logs

# Check node statistics
stats = scheduler.get_node_stats("my_node")
print(f"Ticks: {stats['total_ticks']}, Errors: {stats['errors_count']}")

# Monitor message timestamps
msg, timestamp = node.get_with_timestamp("topic")
age = time.time() - timestamp
print(f"Message age: {age*1000:.1f}ms")
```

---

## Interoperability

### With Rust Nodes

Python and Rust nodes communicate seamlessly:

```python
# Python node publishes
node.send("cmd_vel", {"linear": 1.0, "angular": 0.5})
```

```rust
// Rust node receives
let cmd: CmdVel = hub.recv(ctx)?;
```

### With C Drivers

```python
# Python processing node
def process_lidar(node):
    if node.has_msg("laser_scan"):
        scan = node.get("laser_scan")  # From C driver
        processed = process_scan(scan)
        node.send("obstacles", processed)
```

```c
// C hardware driver
send(scan_pub, &laser_scan);  // Python receives this
```

---

## Common Patterns

### Producer-Consumer

```python
# Producer
producer = horus.Node(
    pubs="queue",
    tick=lambda n: n.send("queue", generate_work())
)

# Consumer
consumer = horus.Node(
    subs="queue",
    tick=lambda n: process_work(n.get("queue")) if n.has_msg("queue") else None
)

horus.run(producer, consumer)
```

### Request-Response

```python
def request_node(node):
    node.send("requests", {"id": 1, "query": "data"})

def response_node(node):
    if node.has_msg("requests"):
        req = node.get("requests")
        response = handle_request(req)
        node.send("responses", response)

req = horus.Node(pubs="requests", tick=request_node)
res = horus.Node(subs="requests", pubs="responses", tick=response_node)
```

### Periodic Tasks

```python
import time

class PeriodicTask:
    def __init__(self, interval):
        self.interval = interval
        self.last_run = 0

task = PeriodicTask(interval=5.0)  # Every 5 seconds

def periodic_tick(node):
    current = time.time()
    if current - task.last_run >= task.interval:
        node.send("periodic", "task_executed")
        task.last_run = current

node = horus.Node(pubs="periodic", tick=periodic_tick, rate=10)
```

---

## Troubleshooting

### Import Errors

```python
# If you see: ModuleNotFoundError: No module named 'horus'
# Rebuild and install:
cd horus_py
maturin develop --release
```

### Slow Performance

```python
# Use release build (not debug)
maturin develop --release

# Check tick rate isn't too high
node = horus.Node(tick=fn, rate=30)  # 30Hz is reasonable
```

### Memory Issues

```python
# Avoid accumulating data in closures
# BAD:
all_data = []
def bad_tick(node):
    all_data.append(node.get("input"))  # Memory leak!

# GOOD:
def good_tick(node):
    data = node.get("input")
    process_and_discard(data)  # Process immediately
```

---

## See Also

- [Examples](/examples) - More code examples
- [Core Concepts](/core-concepts-nodes) - Understanding HORUS architecture
- [Performance](/performance) - Optimization guide
- [C Bindings](/c-bindings) - C API documentation

---

**Remember**: With HORUS Python, you focus on *what* your robot does, not *how* the framework works!
