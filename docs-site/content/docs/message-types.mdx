---
title: Message Types
description: Standard HORUS message types for robotics applications
order: 7
---

# Message Types

HORUS provides a comprehensive library of standard message types for robotics applications. All messages are designed for **shared memory efficiency** with fixed-size structures and zero-copy semantics.

## Message Requirements

All HORUS messages must implement:

```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MyMessage {
    // Your fields here
}
```

**Required traits**:
- `Clone`: For shared memory operations
- `Debug`: For logging and debugging
- `Serialize/Deserialize`: For optional serialization

**Best practices**:
- Use fixed-size arrays instead of `Vec`
- Prefer `f32`/`f64` over variable-length types
- Include timestamp fields for all time-sensitive data
- Use `#[repr(C)]` for C interop

## Geometry Messages

Spatial primitives for representing position, orientation, and motion.

### Twist

3D velocity command with linear and angular components:

```rust
use horus_library::messages::Twist;

// Create 2D twist (common for mobile robots)
let cmd = Twist::new_2d(1.0, 0.5);  // 1.0 m/s forward, 0.5 rad/s rotation

// Create 3D twist
let cmd_3d = Twist::new(
    [1.0, 0.5, 0.0],      // Linear velocity [x, y, z] m/s
    [0.0, 0.0, 0.5]       // Angular velocity [roll, pitch, yaw] rad/s
);

// Stop command
let stop = Twist::stop();

// Check validity
assert!(cmd.is_valid());
```

**Fields**:
- `linear: [f64; 3]` - Linear velocity in m/s
- `angular: [f64; 3]` - Angular velocity in rad/s
- `timestamp: u64` - Nanoseconds since epoch

### Pose2D

2D position and orientation for planar robots:

```rust
use horus_library::messages::Pose2D;

// Create pose
let pose = Pose2D::new(1.0, 2.0, 0.5);  // x=1m, y=2m, theta=0.5rad

// Start at origin
let origin = Pose2D::origin();

// Calculate distance between poses
let distance = pose.distance_to(&origin);

// Normalize angle to [-π, π]
let mut pose = Pose2D::new(1.0, 2.0, 3.5);
pose.normalize_angle();
```

**Fields**:
- `x: f64` - X position in meters
- `y: f64` - Y position in meters
- `theta: f64` - Orientation in radians
- `timestamp: u64` - Nanoseconds since epoch

### Transform

3D transformation with translation and rotation:

```rust
use horus_library::messages::Transform;

// Identity transform
let identity = Transform::identity();

// From 2D pose
let pose2d = Pose2D::new(1.0, 2.0, 0.5);
let transform = Transform::from_pose_2d(&pose2d);

// Custom transform
let tf = Transform::new(
    [1.0, 2.0, 3.0],           // Translation [x, y, z]
    [0.0, 0.0, 0.0, 1.0]       // Rotation quaternion [x, y, z, w]
);

// Normalize quaternion
let mut tf = transform;
tf.normalize_rotation();
```

**Fields**:
- `translation: [f64; 3]` - Position in meters
- `rotation: [f64; 4]` - Quaternion [x, y, z, w]
- `timestamp: u64` - Nanoseconds since epoch

### Point3 and Vector3

3D points and vectors:

```rust
use horus_library::messages::{Point3, Vector3};

// Create point
let point = Point3::new(1.0, 2.0, 3.0);
let distance = point.distance_to(&Point3::origin());

// Create vector
let mut vec = Vector3::new(1.0, 0.0, 0.0);
let magnitude = vec.magnitude();
vec.normalize();

// Vector operations
let dot_product = vec.dot(&Vector3::new(0.0, 1.0, 0.0));
let cross_product = vec.cross(&Vector3::new(0.0, 1.0, 0.0));
```

### Quaternion

3D rotation representation:

```rust
use horus_library::messages::Quaternion;

// Identity quaternion (no rotation)
let q = Quaternion::identity();

// From Euler angles
let q = Quaternion::from_euler(0.0, 0.0, std::f64::consts::PI / 2.0);

// Normalize
let mut q = Quaternion::new(1.0, 0.0, 0.0, 1.0);
q.normalize();
```

## Sensor Messages

Standard sensor data formats for common robotics sensors.

### LaserScan

2D lidar scan data (up to 360 points):

```rust
use horus_library::messages::LaserScan;

let mut scan = LaserScan::new();

// Set range readings (360-element array)
scan.ranges[0] = 5.2;   // Distance in meters
scan.ranges[1] = 3.8;

// Configure scan parameters
scan.angle_min = -std::f32::consts::PI;       // -180 degrees
scan.angle_max = std::f32::consts::PI;        // +180 degrees
scan.range_min = 0.1;                         // Minimum valid range
scan.range_max = 30.0;                        // Maximum valid range
scan.angle_increment = std::f32::consts::PI / 180.0;  // 1 degree

// Get angle for specific reading
let angle = scan.angle_at(45);  // Angle at index 45

// Check if reading is valid
if scan.is_range_valid(0) {
    println!("Range at index 0: {}m", scan.ranges[0]);
}

// Count valid readings
let valid_count = scan.valid_count();

// Find minimum range
if let Some(min) = scan.min_range() {
    println!("Closest obstacle: {}m", min);
}
```

**Fields**:
- `ranges: [f32; 360]` - Range readings in meters (0 = invalid)
- `angle_min/max: f32` - Scan angle range in radians
- `range_min/max: f32` - Valid range limits in meters
- `angle_increment: f32` - Angular resolution in radians
- `scan_time: f32` - Time to complete scan in seconds
- `timestamp: u64` - Nanoseconds since epoch

### IMU

Inertial Measurement Unit data:

```rust
use horus_library::messages::Imu;

let mut imu = Imu::new();

// Set orientation from Euler angles
imu.set_orientation_from_euler(
    0.1,  // Roll in radians
    0.2,  // Pitch in radians
    1.5   // Yaw in radians
);

// Set angular velocity
imu.angular_velocity = [0.1, 0.2, 0.3];  // rad/s

// Set linear acceleration
imu.linear_acceleration = [0.0, 0.0, 9.81];  // m/s²

// Check if orientation is available
if imu.has_orientation() {
    let quat = imu.orientation;
}

// Validate data
assert!(imu.is_valid());

// Get vectors
let angular_vel = imu.angular_velocity_vec();
let linear_accel = imu.linear_acceleration_vec();
```

**Fields**:
- `orientation: [f64; 4]` - Quaternion [x, y, z, w]
- `orientation_covariance: [f64; 9]` - Covariance matrix (-1 = no data)
- `angular_velocity: [f64; 3]` - Gyroscope data in rad/s
- `angular_velocity_covariance: [f64; 9]` - Covariance matrix
- `linear_acceleration: [f64; 3]` - Accelerometer data in m/s²
- `linear_acceleration_covariance: [f64; 9]` - Covariance matrix
- `timestamp: u64` - Nanoseconds since epoch

### Odometry

Combined pose and velocity from wheel encoders or visual odometry:

```rust
use horus_library::messages::{Odometry, Pose2D, Twist};

let mut odom = Odometry::new();

// Set frames
odom.set_frames("odom", "base_link");

// Update pose and velocity
let pose = Pose2D::new(1.0, 2.0, 0.5);
let twist = Twist::new_2d(0.5, 0.2);
odom.update(pose, twist);

// Access data
println!("Position: ({}, {})", odom.pose.x, odom.pose.y);
println!("Velocity: {}m/s", odom.twist.linear[0]);

// Validate
assert!(odom.is_valid());
```

**Fields**:
- `pose: Pose2D` - Current position and orientation
- `twist: Twist` - Current velocity
- `pose_covariance: [f64; 36]` - 6x6 covariance matrix
- `twist_covariance: [f64; 36]` - 6x6 covariance matrix
- `frame_id: [u8; 32]` - Reference frame (e.g., "odom")
- `child_frame_id: [u8; 32]` - Child frame (e.g., "base_link")
- `timestamp: u64` - Nanoseconds since epoch

### Range

Single-point distance sensor (ultrasonic, infrared):

```rust
use horus_library::messages::Range;

// Create ultrasonic range reading
let range = Range::new(Range::ULTRASONIC, 1.5);  // 1.5 meters

// Configure sensor parameters
let mut range = Range::new(Range::INFRARED, 0.8);
range.min_range = 0.02;  // 2cm minimum
range.max_range = 4.0;   // 4m maximum
range.field_of_view = 0.1;  // ~6 degrees

// Check validity
if range.is_valid() {
    println!("Distance: {}m", range.range);
}
```

**Fields**:
- `sensor_type: u8` - Sensor type (0=ultrasonic, 1=infrared)
- `field_of_view: f32` - Sensor FOV in radians
- `min_range: f32` - Minimum valid range in meters
- `max_range: f32` - Maximum valid range in meters
- `range: f32` - Distance reading in meters
- `timestamp: u64` - Nanoseconds since epoch

### BatteryState

Battery status and charge information:

```rust
use horus_library::messages::BatteryState;

let mut battery = BatteryState::new(12.6, 75.0);  // 12.6V, 75% charge

// Set additional parameters
battery.current = -2.5;  // -2.5A (discharging)
battery.charge = 5.0;    // 5 Ah remaining
battery.capacity = 10.0; // 10 Ah total
battery.temperature = 28.5;  // 28.5°C
battery.power_supply_status = BatteryState::STATUS_DISCHARGING;

// Check battery level
if battery.is_low(20.0) {
    println!("Battery low!");
}

if battery.is_critical() {  // Below 10%
    println!("Battery critical!");
}

// Estimate remaining time
if let Some(time_left) = battery.time_remaining() {
    println!("Time remaining: {}s", time_left);
}
```

**Fields**:
- `voltage: f32` - Battery voltage in volts
- `current: f32` - Current in amperes (negative = discharging)
- `charge: f32` - Remaining charge in Ah
- `capacity: f32` - Total capacity in Ah
- `percentage: f32` - Charge percentage (0-100)
- `power_supply_status: u8` - Status (0=unknown, 1=charging, 2=discharging, 3=full)
- `temperature: f32` - Temperature in °C
- `cell_voltages: [f32; 16]` - Individual cell voltages
- `cell_count: u8` - Number of cells
- `timestamp: u64` - Nanoseconds since epoch

## Control Messages

Actuator commands and control parameters (from horus_library).

### CmdVel

Basic velocity command for robot control:

```rust
use horus_library::messages::CmdVel;

// Create command
let cmd = CmdVel::new(1.0, 0.5);  // 1.0 m/s forward, 0.5 rad/s rotation

// Stop command
let stop = CmdVel::zero();

// With explicit timestamp
let cmd = CmdVel::with_timestamp(1.0, 0.5, 123456789);
```

**Fields**:
- `stamp_nanos: u64` - Timestamp in nanoseconds
- `linear: f32` - Forward velocity in m/s
- `angular: f32` - Rotation velocity in rad/s

### Other Control Messages

Available from `horus_library::messages::control`:

**MotorCommand**: Direct motor control

**DifferentialDriveCommand**: Differential drive (left/right wheels)

**ServoCommand**: Servo position/velocity control

**PidConfig**: PID controller parameters

**TrajectoryPoint**: Single point in a trajectory

**JointCommand**: Multi-joint position/velocity/effort

## Vision Messages

Available from `horus_library::messages::vision`:

**Image**: Raw image data

**CompressedImage**: JPEG/PNG compressed images

**CameraInfo**: Camera calibration parameters

**Detection**: Object detection result

**DetectionArray**: Multiple detections

## Navigation Messages

Available from `horus_library::messages::navigation`:

**Goal**: Navigation goal pose

**Path**: Sequence of waypoints

**OccupancyGrid**: 2D occupancy map

**CostMap**: Cost map for path planning

**PathPlan**: Complete path with metadata

## Diagnostics Messages

Available from `horus_library::messages::diagnostics`:

**Heartbeat**: Node health ping

**Status**: Node status with level

**StatusLevel**: Error severity (OK, Warn, Error, Fatal)

**EmergencyStop**: Emergency stop signal

**ResourceUsage**: CPU/memory usage

**DiagnosticValue**: Key-value diagnostic pair

**DiagnosticReport**: Full diagnostic report

**SafetyStatus**: Safety system status

## Custom Messages

### Creating Custom Messages

```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RobotStatus {
    pub battery_level: f32,
    pub temperature: f32,
    pub error_code: u32,
    pub timestamp: u64,
}

impl RobotStatus {
    pub fn new(battery: f32, temp: f32) -> Self {
        Self {
            battery_level: battery,
            temperature: temp,
            error_code: 0,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_nanos() as u64,
        }
    }

    pub fn is_healthy(&self) -> bool {
        self.battery_level > 20.0 && self.temperature < 60.0
    }
}

// Use with Hub
use horus::prelude::*;
let status_pub: Hub<RobotStatus> = Hub::new("robot_status");
status_pub.send(RobotStatus::new(75.0, 42.0), None).ok();
```

### Best Practices for Custom Messages

**Use fixed-size types**:

```rust
// GOOD: Fixed-size array
pub struct LaserData {
    pub ranges: [f32; 360],  // Fixed size
}

// BAD: Variable-size Vec
pub struct LaserData {
    pub ranges: Vec<f32>,  // Requires heap allocation
}
```

**Include timestamps**:

```rust
pub struct MyMessage {
    pub data: f32,
    pub timestamp: u64,  // Always include timestamp
}
```

**Implement helper methods**:

```rust
impl MyMessage {
    pub fn new() -> Self { /* ... */ }
    pub fn is_valid(&self) -> bool { /* ... */ }
    pub fn from_other(other: &OtherMsg) -> Self { /* ... */ }
}
```

**Use repr(C) for C interop**:

```rust
#[repr(C)]  // C-compatible layout
#[derive(Debug, Clone, Copy)]
pub struct CInteropMessage {
    pub x: f32,
    pub y: f32,
}
```

## Message Sizes and Performance

### Typical Message Sizes

| Message Type | Size | Latency (Hub) | Latency (Link) |
|--------------|------|---------------|----------------|
| CmdVel | 16B | ~500ns | 312ns |
| Pose2D | 32B | ~520ns | ~350ns |
| IMU | 304B | ~940ns | ~400ns |
| LaserScan | 1.5KB | ~2.2µs | ~900ns |
| Image (640x480 RGB) | ~1MB | Variable | Variable |

**Key insight**: Latency scales linearly with message size.

### Optimization Tips

**Minimize message size**:

```rust
// Instead of sending full image every frame
pub struct CompressedImage {
    pub data: Vec<u8>,  // JPEG compressed
    pub format: u8,
}

// Or send only regions of interest
pub struct ImageROI {
    pub x: u32,
    pub y: u32,
    pub width: u32,
    pub height: u32,
    pub data: [u8; 4096],  // Fixed-size ROI
}
```

**Use appropriate precision**:

```rust
// For high precision (scientific)
pub struct HighPrecisionPose {
    pub x: f64,  // Double precision
    pub y: f64,
}

// For most robotics (faster)
pub struct FastPose {
    pub x: f32,  // Single precision - sufficient for most cases
    pub y: f32,
}
```

**Avoid unnecessary fields**:

```rust
// GOOD: Only what you need
pub struct SimpleCmdVel {
    pub linear: f32,
    pub angular: f32,
}

// BAD: Extra unused fields
pub struct VerboseCmdVel {
    pub linear: f32,
    pub angular: f32,
    pub metadata: [u8; 256],  // Unused
    pub debug_info: [u8; 512],  // Unused
}
```

## Working with Messages in Nodes

### Publishing Messages

```rust
use horus::prelude::*;
use horus_library::messages::LaserScan;

struct LidarNode {
    scan_pub: Hub<LaserScan>,
}

impl Node for LidarNode {
    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        let mut scan = LaserScan::new();
        // Fill in scan data...
        scan.ranges[0] = 5.2;

        self.scan_pub.send(scan, ctx).ok();
    }
}
```

### Subscribing to Messages

```rust
use horus::prelude::*;
use horus_library::messages::LaserScan;

struct ObstacleDetector {
    scan_sub: Hub<LaserScan>,
}

impl Node for ObstacleDetector {
    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        if let Some(scan) = self.scan_sub.recv(ctx) {
            // Find closest obstacle
            if let Some(min_range) = scan.min_range() {
                if min_range < 0.5 {
                    // Obstacle too close!
                }
            }
        }
    }
}
```

## Complete Working Examples

Learn by example - these are complete, runnable applications demonstrating message usage.

### Example 1: Robot Teleop Controller (CmdVel)

Complete differential drive robot controller using CmdVel messages.

**File: `teleop_robot.rs`**

```rust
use horus::prelude::*;
use horus_library::messages::CmdVel;

// Simulated keyboard input node
struct TeleopNode {
    cmd_pub: Hub<CmdVel>,
    mode: u8,  // 0=stop, 1=forward, 2=backward, 3=turn
}

impl TeleopNode {
    fn new() -> Result<Self> {
        Ok(Self {
            cmd_pub: Hub::new("cmd_vel")?,
            mode: 1,
        })
    }
}

impl Node for TeleopNode {
    fn name(&self) -> &'static str { "TeleopNode" }

    fn init(&mut self, ctx: &mut NodeInfo) -> Result<(), String> {
        ctx.log_info("Teleop initialized - W/A/S/D to control");
        Ok(())
    }

    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        // Simulate keyboard input cycling through modes
        let cmd = match self.mode {
            1 => CmdVel::new(1.0, 0.0),    // Forward
            2 => CmdVel::new(-0.5, 0.0),   // Backward
            3 => CmdVel::new(0.0, 0.8),    // Turn left
            _ => CmdVel::zero(),            // Stop
        };

        self.cmd_pub.send(cmd, ctx).ok();

        if let Some(ctx) = ctx {
            ctx.log_info(&format!(
                "Mode {}: linear={:.2}, angular={:.2}",
                self.mode, cmd.linear, cmd.angular
            ));
        }

        // Cycle modes every 50 ticks
        self.mode = (self.mode + 1) % 4;
    }

    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<(), String> {
        // Send stop command on shutdown
        self.cmd_pub.send(CmdVel::zero(), None).ok();
        ctx.log_info("Teleop stopped - robot stopped");
        Ok(())
    }
}

// Motor driver node - converts CmdVel to wheel speeds
struct MotorDriver {
    cmd_sub: Hub<CmdVel>,
    wheel_base: f32,  // Distance between wheels in meters
}

impl MotorDriver {
    fn new(wheel_base: f32) -> Result<Self> {
        Ok(Self {
            cmd_sub: Hub::new("cmd_vel")?,
            wheel_base,
        })
    }
}

impl Node for MotorDriver {
    fn name(&self) -> &'static str { "MotorDriver" }

    fn init(&mut self, ctx: &mut NodeInfo) -> Result<(), String> {
        ctx.log_info(&format!(
            "Motor driver initialized - wheel base: {:.2}m",
            self.wheel_base
        ));
        Ok(())
    }

    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        if let Some(cmd) = self.cmd_sub.recv(ctx) {
            // Convert to differential drive wheel speeds
            // left = linear - (angular * wheel_base / 2)
            // right = linear + (angular * wheel_base / 2)
            let left_speed = cmd.linear - (cmd.angular * self.wheel_base / 2.0);
            let right_speed = cmd.linear + (cmd.angular * self.wheel_base / 2.0);

            if let Some(ctx) = ctx {
                ctx.log_info(&format!(
                    "Motors: LEFT={:.2} m/s, RIGHT={:.2} m/s",
                    left_speed, right_speed
                ));
            }

            // In production: send to actual motor hardware
            // motor_controller.set_left_speed(left_speed)?;
            // motor_controller.set_right_speed(right_speed)?;
        }
    }

    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<(), String> {
        ctx.log_info("Motors stopped");
        Ok(())
    }
}

fn main() -> Result<()> {
    let mut scheduler = Scheduler::new();

    // Teleop publishes commands
    scheduler.add(Box::new(TeleopNode::new()?), 0, Some(true));

    // Motor driver subscribes and controls wheels
    scheduler.add(Box::new(MotorDriver::new(0.3)?), 1, Some(true));

    scheduler.run()?;
    Ok(())
}
```

**Run it:**
```bash
horus run teleop_robot.rs
```

**What it demonstrates:**
- Creating and publishing CmdVel messages
- Subscribing to CmdVel and processing commands
- Converting twist commands to differential drive wheel speeds
- Safe shutdown (sending stop command in shutdown())

---

### Example 2: IMU Sensor Fusion (IMU + Odometry)

Fuse IMU and wheel odometry for better position estimates.

**File: `sensor_fusion.rs`**

```rust
use horus::prelude::*;
use horus_library::messages::{Imu, Odometry, Pose2D, Twist};

// IMU sensor node - provides orientation and angular velocity
struct ImuSensorNode {
    imu_pub: Hub<Imu>,
    angle: f64,
}

impl ImuSensorNode {
    fn new() -> Result<Self> {
        Ok(Self {
            imu_pub: Hub::new("imu_raw")?,
            angle: 0.0,
        })
    }
}

impl Node for ImuSensorNode {
    fn name(&self) -> &'static str { "ImuSensor" }

    fn init(&mut self, ctx: &mut NodeInfo) -> Result<(), String> {
        ctx.log_info("IMU sensor initialized");
        Ok(())
    }

    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        let mut imu = Imu::new();

        // Simulate IMU readings
        self.angle += 0.01;  // Rotating slowly

        // Set orientation from Euler angles (roll, pitch, yaw)
        imu.set_orientation_from_euler(0.0, 0.0, self.angle);

        // Set angular velocity (rotating around Z axis)
        imu.angular_velocity = [0.0, 0.0, 0.01];  // 0.01 rad/s

        // Simulate accelerometer (gravity + small noise)
        imu.linear_acceleration = [0.05, 0.03, 9.81];

        if imu.is_valid() {
            self.imu_pub.send(imu, ctx).ok();

            if let Some(ctx) = ctx {
                ctx.log_debug(&format!(
                    "IMU: yaw={:.2} rad, gyro_z={:.3} rad/s",
                    self.angle, imu.angular_velocity[2]
                ));
            }
        }
    }

    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<(), String> {
        ctx.log_info("IMU sensor stopped");
        Ok(())
    }
}

// Wheel odometry node - provides position estimate
struct WheelOdomNode {
    odom_pub: Hub<Odometry>,
    x: f64,
    y: f64,
    theta: f64,
    velocity: f64,
}

impl WheelOdomNode {
    fn new() -> Result<Self> {
        Ok(Self {
            odom_pub: Hub::new("odom_raw")?,
            x: 0.0,
            y: 0.0,
            theta: 0.0,
            velocity: 0.5,  // 0.5 m/s forward
        })
    }
}

impl Node for WheelOdomNode {
    fn name(&self) -> &'static str { "WheelOdom" }

    fn init(&mut self, ctx: &mut NodeInfo) -> Result<(), String> {
        ctx.log_info("Wheel odometry initialized");
        Ok(())
    }

    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        // Update position based on velocity (simple dead reckoning)
        let dt = 0.01;  // Assume 100Hz
        self.x += self.velocity * self.theta.cos() * dt;
        self.y += self.velocity * self.theta.sin() * dt;
        self.theta += 0.01;  // Slight rotation

        // Create odometry message
        let mut odom = Odometry::new();
        odom.set_frames("odom", "base_link");

        let pose = Pose2D::new(self.x, self.y, self.theta);
        let twist = Twist::new_2d(self.velocity, 0.01);
        odom.update(pose, twist);

        if odom.is_valid() {
            self.odom_pub.send(odom, ctx).ok();

            if let Some(ctx) = ctx {
                ctx.log_debug(&format!(
                    "Odom: x={:.2}, y={:.2}, theta={:.2}",
                    self.x, self.y, self.theta
                ));
            }
        }
    }

    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<(), String> {
        ctx.log_info("Wheel odometry stopped");
        Ok(())
    }
}

// Sensor fusion node - combines IMU + odometry
struct SensorFusionNode {
    imu_sub: Hub<Imu>,
    odom_sub: Hub<Odometry>,
    fused_pub: Hub<Odometry>,
}

impl SensorFusionNode {
    fn new() -> Result<Self> {
        Ok(Self {
            imu_sub: Hub::new("imu_raw")?,
            odom_sub: Hub::new("odom_raw")?,
            fused_pub: Hub::new("odom_fused")?,
        })
    }
}

impl Node for SensorFusionNode {
    fn name(&self) -> &'static str { "SensorFusion" }

    fn init(&mut self, ctx: &mut NodeInfo) -> Result<(), String> {
        ctx.log_info("Sensor fusion initialized");
        Ok(())
    }

    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        // Get latest IMU data
        let imu_opt = self.imu_sub.recv(ctx);

        // Get latest odometry data
        let odom_opt = self.odom_sub.recv(ctx);

        if let (Some(imu), Some(mut odom)) = (imu_opt, odom_opt) {
            // Fuse: Use odometry position, but IMU orientation
            // (IMU gyros are typically more accurate than wheel encoders for orientation)

            // Extract yaw from IMU quaternion
            let q = imu.orientation;
            let imu_yaw = (2.0 * (q[3] * q[2] + q[0] * q[1])).atan2(
                1.0 - 2.0 * (q[1].powi(2) + q[2].powi(2))
            );

            // Update odometry with IMU orientation
            odom.pose.theta = imu_yaw;

            // Update angular velocity from IMU
            odom.twist.angular[2] = imu.angular_velocity[2];

            // Publish fused estimate
            self.fused_pub.send(odom, ctx).ok();

            if let Some(ctx) = ctx {
                ctx.log_info(&format!(
                    "Fused: pos=({:.2}, {:.2}), yaw={:.2} rad (from IMU)",
                    odom.pose.x, odom.pose.y, imu_yaw
                ));
            }
        }
    }

    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<(), String> {
        ctx.log_info("Sensor fusion stopped");
        Ok(())
    }
}

fn main() -> Result<()> {
    let mut scheduler = Scheduler::new();

    // Sensor nodes (priority 0)
    scheduler.add(Box::new(ImuSensorNode::new()?), 0, Some(true));
    scheduler.add(Box::new(WheelOdomNode::new()?), 0, Some(true));

    // Fusion node (priority 1 - runs after sensors)
    scheduler.add(Box::new(SensorFusionNode::new()?), 1, Some(true));

    scheduler.run()?;
    Ok(())
}
```

**Run it:**
```bash
horus run sensor_fusion.rs
```

**What it demonstrates:**
- Creating and publishing IMU messages
- Setting orientation from Euler angles
- Creating Odometry messages with Pose2D and Twist
- Simple sensor fusion (combining IMU + odometry)
- Extracting yaw angle from quaternion

---

### Example 3: Custom Message Type for Multi-Sensor System

Create a custom message for a complex sensor payload.

**File: `custom_sensor.rs`**

```rust
use horus::prelude::*;
use serde::{Serialize, Deserialize};
use std::time::{SystemTime, UNIX_EPOCH};

// Custom message: Combined sensor reading
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MultiSensorReading {
    pub timestamp: u64,           // Nanoseconds since epoch
    pub temperature: f32,          // Celsius
    pub humidity: f32,             // Percentage
    pub pressure: f32,             // hPa
    pub light_level: u16,          // Lux
    pub motion_detected: bool,     // PIR sensor
    pub battery_voltage: f32,      // Volts
    pub sensor_id: u32,            // Unique sensor ID
}

impl MultiSensorReading {
    pub fn new(sensor_id: u32) -> Self {
        Self {
            timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_nanos() as u64,
            temperature: 0.0,
            humidity: 0.0,
            pressure: 0.0,
            light_level: 0,
            motion_detected: false,
            battery_voltage: 0.0,
            sensor_id,
        }
    }

    pub fn is_valid(&self) -> bool {
        // Validation: temperature in reasonable range
        self.temperature > -40.0 && self.temperature < 85.0 &&
        // Humidity 0-100%
        self.humidity >= 0.0 && self.humidity <= 100.0 &&
        // Pressure in reasonable range (hPa)
        self.pressure > 800.0 && self.pressure < 1200.0 &&
        // Battery above minimum
        self.battery_voltage > 2.5
    }

    pub fn battery_percentage(&self) -> f32 {
        // Assume 3.0V = 0%, 4.2V = 100%
        ((self.battery_voltage - 3.0) / 1.2 * 100.0).clamp(0.0, 100.0)
    }
}

// Multi-sensor device node
struct MultiSensorDevice {
    sensor_pub: Hub<MultiSensorReading>,
    sensor_id: u32,
    counter: f32,
}

impl MultiSensorDevice {
    fn new(sensor_id: u32) -> Result<Self> {
        Ok(Self {
            sensor_pub: Hub::new("multi_sensor_data")?,
            sensor_id,
            counter: 0.0,
        })
    }
}

impl Node for MultiSensorDevice {
    fn name(&self) -> &'static str { "MultiSensorDevice" }

    fn init(&mut self, ctx: &mut NodeInfo) -> Result<(), String> {
        ctx.log_info(&format!("Multi-sensor {} initialized", self.sensor_id));
        Ok(())
    }

    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        // Simulate sensor readings
        let mut reading = MultiSensorReading::new(self.sensor_id);

        reading.temperature = 22.0 + (self.counter * 0.1).sin() * 5.0;
        reading.humidity = 50.0 + (self.counter * 0.15).cos() * 20.0;
        reading.pressure = 1013.25 + (self.counter * 0.05).sin() * 10.0;
        reading.light_level = ((500.0 + self.counter.sin() * 200.0) as u16).max(0);
        reading.motion_detected = self.counter as u32 % 20 == 0;
        reading.battery_voltage = 3.7 - (self.counter * 0.0001);  // Slow discharge

        // Validate before publishing
        if reading.is_valid() {
            self.sensor_pub.send(reading.clone(), ctx).ok();

            if let Some(ctx) = ctx {
                ctx.log_debug(&format!(
                    "Sensor {}: {:.1}°C, {:.0}% humidity, {}V ({:.0}% battery)",
                    reading.sensor_id,
                    reading.temperature,
                    reading.humidity,
                    reading.battery_voltage,
                    reading.battery_percentage()
                ));
            }
        } else {
            if let Some(ctx) = ctx {
                ctx.log_warn("Invalid sensor reading - skipping");
            }
        }

        self.counter += 0.1;
    }

    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<(), String> {
        ctx.log_info(&format!("Sensor {} stopped", self.sensor_id));
        Ok(())
    }
}

// Data aggregator node - processes multiple sensors
struct SensorAggregator {
    sensor_sub: Hub<MultiSensorReading>,
    readings_count: u32,
    total_temp: f32,
}

impl SensorAggregator {
    fn new() -> Result<Self> {
        Ok(Self {
            sensor_sub: Hub::new("multi_sensor_data")?,
            readings_count: 0,
            total_temp: 0.0,
        })
    }
}

impl Node for SensorAggregator {
    fn name(&self) -> &'static str { "SensorAggregator" }

    fn init(&mut self, ctx: &mut NodeInfo) -> Result<(), String> {
        ctx.log_info("Sensor aggregator initialized");
        Ok(())
    }

    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        // Process all available sensor readings
        let mut readings_this_tick = 0;

        while let Some(reading) = self.sensor_sub.recv(ctx) {
            readings_this_tick += 1;
            self.readings_count += 1;
            self.total_temp += reading.temperature;

            // Check for alerts
            if reading.motion_detected {
                if let Some(ctx) = ctx {
                    ctx.log_warn(&format!(
                        "Motion detected by sensor {}",
                        reading.sensor_id
                    ));
                }
            }

            if reading.battery_percentage() < 20.0 {
                if let Some(ctx) = ctx {
                    ctx.log_warn(&format!(
                        "Low battery on sensor {}: {:.0}%",
                        reading.sensor_id,
                        reading.battery_percentage()
                    ));
                }
            }
        }

        // Report statistics every 100 ticks
        if self.readings_count % 100 == 0 && self.readings_count > 0 {
            let avg_temp = self.total_temp / self.readings_count as f32;

            if let Some(ctx) = ctx {
                ctx.log_info(&format!(
                    "Stats: {} readings, avg temp: {:.1}°C",
                    self.readings_count, avg_temp
                ));
            }
        }
    }

    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<(), String> {
        ctx.log_info(&format!(
            "Aggregator stopped - processed {} readings",
            self.readings_count
        ));
        Ok(())
    }
}

fn main() -> Result<()> {
    let mut scheduler = Scheduler::new();

    // Multiple sensor devices
    scheduler.add(Box::new(MultiSensorDevice::new(1)?), 0, Some(true));
    scheduler.add(Box::new(MultiSensorDevice::new(2)?), 0, Some(true));

    // Aggregator (runs after sensors)
    scheduler.add(Box::new(SensorAggregator::new()?), 1, Some(true));

    scheduler.run()?;
    Ok(())
}
```

**Run it:**
```bash
horus run custom_sensor.rs
```

**What it demonstrates:**
- Defining custom message types with `#[derive(Clone, Serialize, Deserialize)]`
- Adding validation methods (`is_valid()`, `battery_percentage()`)
- Publishing custom messages through Hub
- Subscribing to custom messages
- Processing multiple messages per tick (aggregation pattern)
- Generating timestamps with `SystemTime`

---

## Next Steps

- **[Basic Examples](/basic-examples)** - Learn fundamental patterns
- **[Advanced Examples](/advanced-examples)** - State machines, multi-process systems
- **[Second Application](/second-application)** - Build a 3-node pipeline
- **[API Reference](/api)** - Detailed message type documentation
- **[Performance Optimization](/performance)** - Optimize for large messages
- **[Python Bindings](/python-bindings)** and **[C Bindings](/c-bindings)** - Multi-language support
