---
title: PidControllerNode
description: PID control loop for precise servo control
---

# PidControllerNode

Proportional-Integral-Derivative (PID) controller node for closed-loop control of position, velocity, temperature, and other process variables. Provides tunable PID gains and anti-windup.

## Source Code

- [PidControllerNode Implementation](https://github.com/softmata/horus/tree/main/horus_library/nodes/pid_controller)
- [Control Messages](https://github.com/softmata/horus/blob/main/horus_library/messages/control.rs)

## Features

- P, PI, PD, and PID control modes
- Anti-windup protection
- Derivative filtering
- Setpoint ramping
- Output limiting
- Auto-tuning (Ziegler-Nichols)
- Multiple controllers
- Simulation support

## Quick Start

```rust
use horus_library::prelude::*;

fn main() -> Result<()> {
    let mut scheduler = Scheduler::new();

    let mut pid = PidControllerNode::new()?;
    pid.set_gains(1.0, 0.1, 0.05);  // Kp, Ki, Kd

    scheduler.add(Box::new(pid), 1, Some(true));
    scheduler.run()?;
    Ok(())
}
```

## Configuration

```rust
// Set PID gains
pid.set_gains(2.0, 0.5, 0.1);  // Kp, Ki, Kd

// Set output limits
pid.set_output_limits(-100.0, 100.0);

// Set integral limits (anti-windup)
pid.set_integral_limits(-50.0, 50.0);

// Set deadband (minimum error threshold)
pid.set_deadband(0.01);

// Set motor ID for output commands
pid.set_motor_id(0);

// Reset PID controller state
pid.reset();
```

## Usage

The PidControllerNode uses the following default topics (configurable via `new_with_topics`):
- Subscribes to `"setpoint"` - desired target value (f32)
- Subscribes to `"feedback"` - current measured value (f32)
- Subscribes to `"pid_config"` - runtime PID configuration (PidConfig)
- Publishes to `"pid_output"` - control output (MotorCommand)

```rust
// Create with custom topics
let pid = PidControllerNode::new_with_topics(
    "my_setpoint",      // setpoint topic
    "my_feedback",      // feedback topic
    "my_output",        // output topic
    "my_config"         // config topic
)?;

// Publish setpoint from another node
let setpoint_hub = Hub::<f32>::new("setpoint")?;
setpoint_hub.send(150.0, &mut None)?;

// Publish feedback from another node
let feedback_hub = Hub::<f32>::new("feedback")?;
feedback_hub.send(current_position, &mut None)?;

// Read output from another node
let output_hub = Hub::<MotorCommand>::new("pid_output")?;
if let Some(cmd) = output_hub.recv(&mut None) {
    println!("PID output: {:.2}", cmd.value);
}
```

## See Also

- [DifferentialDriveNode](./differential-drive) - Drive control
- [StepperMotorNode](./stepper-motor) - Position control
- [RoboclawMotorNode](./roboclaw-motor) - Motor with PID
