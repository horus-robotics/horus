---
title: LidarNode
description: 2D/3D LiDAR laser rangefinder for mapping and obstacle detection
---

# LidarNode

LiDAR (Light Detection and Ranging) node for 2D and 3D laser rangefinding. Supports RPLidar, YDLIDAR, Hokuyo, SICK, and Velodyne sensors for SLAM, navigation, and obstacle detection.

## Source Code

- [LidarNode Implementation](https://github.com/softmata/horus/tree/main/horus_library/nodes/lidar)
- [Perception Messages](https://github.com/softmata/horus/blob/main/horus_library/messages/perception.rs)

## Features

- RPLidar A1/A2/A3, YDLIDAR X2/X4
- Hokuyo URG series, SICK TiM/LMS
- Velodyne (3D LiDAR)
- 360° scanning
- Configurable scan rate (5-20 Hz)
- Point cloud output
- Obstacle detection
- Hardware fallback to simulation

## Quick Start

```rust
use horus_library::prelude::*;

fn main() -> Result<()> {
    let mut scheduler = Scheduler::new();

    // Create LiDAR node with specific backend
    let mut lidar = LidarNode::new_with_backend("scan", LidarBackend::RplidarA2)?;
    lidar.set_serial_port("/dev/ttyUSB0");
    lidar.set_scan_frequency(10.0);  // 10 Hz

    scheduler.add(Box::new(lidar), 1, Some(true));
    scheduler.run()?;
    Ok(())
}
```

## Configuration

```rust
// Set LiDAR backend (RplidarA1, RplidarA2, RplidarA3, YdlidarX2, YdlidarX4, YdlidarTMiniPro, Simulation)
lidar.set_backend(LidarBackend::RplidarA2);

// Set serial port for hardware LiDAR
lidar.set_serial_port("/dev/ttyUSB0");

// Set frame ID for coordinate system
lidar.set_frame_id("laser_frame");

// Set scan frequency (Hz)
lidar.set_scan_frequency(10.0);

// Set range limits (meters)
lidar.set_range_limits(0.1, 16.0);

// Set angular resolution (radians)
lidar.set_angle_increment(std::f32::consts::PI / 180.0);  // 1 degree
```

## Usage

The LidarNode publishes to the following topic (configurable via `new_with_topic` or `new_with_backend`):
- Publishes to `"scan"` - laser scan data (LaserScan)

```rust
let hub = Hub::<LaserScan>::new("scan")?;

if let Some(scan) = hub.recv(&mut None) {
    // Iterate over ranges (360 measurements)
    for (i, &range) in scan.ranges.iter().enumerate() {
        if range < 0.5 {  // Obstacle within 0.5m
            let angle_deg = i as f32 * scan.angle_increment.to_degrees();
            println!("Obstacle at {:.2}m, angle {:.0}°", range, angle_deg);
        }
    }
}

// Get actual scan rate
let rate = lidar.get_actual_scan_rate();
```

**Note**: RPLidar and YDLIDAR hardware support is temporarily limited due to upstream driver issues. When hardware is unavailable, the node automatically falls back to simulation mode.

## See Also

- [UltrasonicNode](./ultrasonic) - Short-range sensors
- [DepthCameraNode](./depth-camera) - 3D depth sensing
- [CollisionDetectorNode](./collision-detector) - Collision avoidance
