---
title: ImuNode
description: Inertial Measurement Unit with accelerometer, gyroscope, and magnetometer
---

# ImuNode

Inertial Measurement Unit (IMU) node supporting MPU6050, MPU9250, BNO055, and other I2C-based IMUs. Provides accelerometer, gyroscope, magnetometer data, and sensor fusion for orientation estimation in robots, drones, and stabilization systems.

## Source Code

- [ImuNode Implementation](https://github.com/softmata/horus/tree/main/horus_library/nodes/imu)
- [IMU Sensor Messages](https://github.com/softmata/horus/blob/main/horus_library/messages/sensor.rs)

## Features

- MPU6050/6500 (6-axis: accel + gyro)
- MPU9250 (9-axis: accel + gyro + mag)
- BNO055 (9-axis with hardware fusion)
- LSM6DS3, LSM9DS1 support
- Raw sensor data output
- Sensor fusion (Mahony/Madgwick filters)
- Quaternion and Euler angle output
- Calibration routines
- Configurable sample rates (up to 1kHz)
- DMP (Digital Motion Processor) support
- Hardware fallback to simulation

## Quick Start

```rust
use horus_library::prelude::*;

fn main() -> Result<()> {
    let mut scheduler = Scheduler::new();

    // Create IMU node with specific backend
    let mut imu = ImuNode::new_with_backend("imu", ImuBackend::Mpu6050)?;
    imu.set_i2c_config("/dev/i2c-1", 0x68);  // Bus and address

    scheduler.add(Box::new(imu), 1, Some(true));
    scheduler.run()?;
    Ok(())
}
```

## Hardware Setup

### MPU6050/6500 Wiring

```
Raspberry Pi    MPU6050
GPIO 2 (SDA) --> SDA
GPIO 3 (SCL) --> SCL
3.3V         --> VCC
GND          --- GND
```

### BNO055 Wiring

```
Raspberry Pi    BNO055
GPIO 2 (SDA) --> SDA
GPIO 3 (SCL) --> SCL
3.3V         --> VIN
GND          --- GND
                PS0 --> GND (I2C mode)
                PS1 --> GND
```

### Enable in Project

```toml
[dependencies]
horus_library = { version = "0.1", features = ["i2c-hardware"] }
```

## Configuration

```rust
let mut imu = ImuNode::new()?;

// Set hardware backend (Mpu6050, Bno055, Icm20948, Simulation)
imu.set_backend(ImuBackend::Mpu6050);

// Set I2C bus and address for hardware IMU
imu.set_i2c_config("/dev/i2c-1", 0x68);

// Set frame ID for coordinate system
imu.set_frame_id("imu_link");

// Set IMU sample rate (Hz)
imu.set_sample_rate(100.0);  // 100 Hz
```

## Usage Patterns

### Reading IMU Data

The ImuNode publishes to the following topic (configurable via `new_with_topic` or `new_with_backend`):
- Publishes to `"imu"` - IMU sensor data (Imu)

```rust
let hub = Hub::<Imu>::new("imu")?;

if let Some(data) = hub.recv(&mut None) {
    // Orientation as quaternion [x, y, z, w]
    println!("Orientation: [{:.3}, {:.3}, {:.3}, {:.3}]",
        data.orientation[0], data.orientation[1],
        data.orientation[2], data.orientation[3]);

    // Angular velocity [x, y, z] in rad/s
    println!("Angular velocity: [{:.2}, {:.2}, {:.2}] rad/s",
        data.angular_velocity[0], data.angular_velocity[1],
        data.angular_velocity[2]);

    // Linear acceleration [x, y, z] in m/s²
    println!("Acceleration: [{:.2}, {:.2}, {:.2}] m/s²",
        data.linear_acceleration[0], data.linear_acceleration[1],
        data.linear_acceleration[2]);
}

// Get actual sample rate
let rate = imu.get_actual_sample_rate();
```

## Best Practices

1. **Always calibrate on startup**
2. **Enable sensor fusion for orientation**
3. **Mount IMU at robot center of mass**
4. **Align IMU axes with robot frame**

## See Also

- [GpsNode](./gps) - GPS positioning
- [EncoderNode](./encoder) - Wheel encoders
- [OdometryNode](./odometry) - Position tracking
