---
title: Core Concepts - Nodes
description: Understanding HORUS nodes and their lifecycle
order: 5
---

# Nodes and Lifecycle

## Key Takeaways

After reading this guide, you will understand:
- How nodes are self-contained units of computation that run in the scheduler
- The Node trait's lifecycle methods (init, tick, shutdown) and when each is called
- How NodeInfo provides logging, metrics, and timing context to your nodes
- When to use different priority levels (0 for safety-critical, 100 for background logging)
- Communication patterns (publisher, subscriber, pipeline, aggregator) for building node graphs

Nodes are the fundamental building blocks of HORUS applications. Every component in your robotics system is a node - sensors, actuators, controllers, filters, and more.

## What is a Node?

A node is a **self-contained unit of computation** that runs in the HORUS scheduler. Nodes communicate with each other through the Hub pub/sub system using shared memory IPC.

### Key Characteristics

**Lifecycle Management**: Nodes have explicit initialization, execution, and shutdown phases

**Priority-Based Execution**: Nodes run in priority order every tick cycle

**Zero Boilerplate**: The `node!` macro generates all necessary boilerplate code

**Type-Safe Communication**: Compile-time guarantees for message passing

**Memory Safety**: Written in Rust with zero unsafe code in user-facing APIs

## The Node Trait

Every HORUS node implements the `Node` trait:

```rust
pub trait Node: Send {
    fn name(&self) -> &'static str;
    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()>;
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>);
    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()>;
    fn get_publishers(&self) -> Vec<TopicMetadata>;
    fn get_subscribers(&self) -> Vec<TopicMetadata>;
}
```

### Required Methods

**name()**: Returns a static string identifying the node

```rust
fn name(&self) -> &'static str {
    "MyNode"
}
```

**tick()**: Main execution loop called repeatedly by the scheduler

```rust
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    // Your node logic here
}
```

### Optional Methods

**init()**: Called once during node startup (default: no-op)

```rust
fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {
    ctx.log_info("Node starting up");
    // Initialize resources, open files, etc.
    Ok(())
}
```

**shutdown()**: Called once during graceful shutdown (default: no-op)

```rust
fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {
    ctx.log_info("Node shutting down");
    // Clean up resources, close connections, etc.
    Ok(())
}
```

**get_publishers()**: Returns list of published topics (default: empty)

```rust
fn get_publishers(&self) -> Vec<TopicMetadata> {
    vec![
        TopicMetadata {
            topic_name: "cmd_vel".to_string(),
            type_name: "CmdVel".to_string(),
        }
    ]
}
```

**get_subscribers()**: Returns list of subscribed topics (default: empty)

```rust
fn get_subscribers(&self) -> Vec<TopicMetadata> {
    vec![
        TopicMetadata {
            topic_name: "laser_scan".to_string(),
            type_name: "LaserScan".to_string(),
        }
    ]
}
```

## Node Lifecycle

Nodes transition through well-defined states during their lifetime:

### Lifecycle States

**Uninitialized**: Node created but not added to scheduler

**Initializing**: Running `init()` method

**Running**: Executing `tick()` in main loop

**Paused**: Temporarily suspended (future feature)

**Stopping**: Running `shutdown()` method

**Stopped**: Clean shutdown complete

**Error**: Recoverable error occurred

**Crashed**: Unrecoverable error, node terminated

### State Transitions

```
Uninitialized  Initializing  Running  Stopping  Stopped
                                  ->
                               Error  Running
                                  ->
                              Crashed (terminal)
```

### Lifecycle Example

```rust
use horus::prelude::*;

struct LifecycleDemo {
    counter: u32,
}

impl Node for LifecycleDemo {
    fn name(&self) -> &'static str {
        "LifecycleDemo"
    }

    fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {
        // Called ONCE when node starts
        ctx.log_info("Initializing resources");
        self.counter = 0;
        Ok(())
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Called REPEATEDLY in main loop (~60 FPS default)
        self.counter += 1;

        ctx.log_debug(&format!("Tick #{}", self.counter));
    }

    fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {
        // Called ONCE during graceful shutdown
        ctx.log_info(&format!("Shutting down after {} ticks", self.counter));
        Ok(())
    }
}
```

## NodeInfo Context

The `NodeInfo` struct provides comprehensive context and utilities for nodes:

### Structure

```rust
pub struct NodeInfo {
    pub name: &'static str,
    pub state: NodeState,
    pub priority: u32,  // Lower number = higher priority (0 = highest)
    pub metrics: NodeMetrics,
    pub publishers: Vec<TopicMetadata>,
    pub subscribers: Vec<TopicMetadata>,
    // Internal timing and logging fields
}
```

### Logging Methods

**log_info()**: General information messages

```rust
ctx.log_info("Robot ready");
```

**log_warning()**: Warning messages that don't stop execution

```rust
ctx.log_warning("Battery low");
```

**log_error()**: Error messages

```rust
ctx.log_error("Sensor disconnected");
```

**log_debug()**: Detailed debugging information

```rust
ctx.log_debug(&format!("Position: ({}, {})", x, y));
```

### Pub/Sub Logging (Automatic)

When you pass `ctx` to `Hub::send()` or `Hub::recv()`, HORUS automatically logs IPC operations:

```rust
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    // Automatic pub logging - just pass ctx to send()
    self.velocity_pub.send(1.5, &mut ctx).ok();
    // Output: [12:34:56.789] [IPC: 437ns | Tick: 12μs] MyNode --PUB--> 'cmd_vel' = 1.5

    // Automatic sub logging - just pass ctx to recv()
    if let Some(scan) = self.lidar_sub.recv(&mut ctx) {
        // Output: [12:34:56.789] [IPC: 142ns | Tick: 8μs] MyNode <--SUB-- 'laser_scan' = LaserScan { ... }
        self.process(scan);
    }
}
```

**You don't need to call any logging methods manually** - Hub handles it automatically when you pass `ctx`.

### Performance Metrics

NodeInfo tracks detailed performance metrics:

```rust
pub struct NodeMetrics {
    pub total_ticks: u64,
    pub successful_ticks: u64,
    pub failed_ticks: u64,
    pub avg_tick_duration_ms: f64,
    pub max_tick_duration_ms: f64,
    pub min_tick_duration_ms: f64,
    pub last_tick_duration_ms: f64,
    pub cpu_usage_percent: f64,
    pub memory_usage_bytes: u64,
    pub messages_sent: u64,
    pub messages_received: u64,
    pub errors_count: u64,
    pub warnings_count: u64,
    pub uptime_seconds: f64,
}
```

Access metrics in your node:

```rust
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    if let Some(ctx) = ctx {
        let avg_duration = ctx.metrics.avg_tick_duration_ms;
        if avg_duration > 1.0 {
            ctx.log_warning("Tick duration exceeding 1ms");
        }
    }
}
```

### Timing Methods

**start_tick()**: Called automatically at the start of each tick

**record_tick()**: Called automatically at the end of each tick

These methods track tick duration and update metrics.

## Node Priority

Nodes execute in **priority order** each tick cycle:

### Priority Levels

Priorities are represented as `u32` values where **lower numbers = higher priority**.

Common priority values:

```rust
// Recommended priority constants
const CRITICAL: u32    = 0;   // Highest priority
const HIGH: u32        = 10;
const NORMAL: u32      = 50;  // Default
const LOW: u32         = 80;
const BACKGROUND: u32  = 100; // Lowest priority
```

You can use **any u32 value** for fine-grained control (e.g., 5, 15, 25, 37, 42, etc.).

### Priority Usage

```rust
use horus::prelude::*;

let mut scheduler = Scheduler::new();

// Safety monitor runs FIRST every tick (priority 0)
scheduler.add(Box::new(safety_node), 0, None);

// Controller runs second (priority 10)
scheduler.add(Box::new(control_node), 10, None);

// Sensors run third (priority 50)
scheduler.add(Box::new(sensor_node), 50, None);

// Logging runs LAST (priority 100)
scheduler.add(Box::new(logger_node), 100, None);

// Fine-grained priorities for complex systems
scheduler.add(Box::new(emergency_stop), 0, None);    // Highest
scheduler.add(Box::new(motor_control), 15, None);    // Between HIGH and NORMAL
scheduler.add(Box::new(vision_processing), 55, None); // Slightly lower than normal
scheduler.add(Box::new(telemetry), 90, None);        // Between LOW and BACKGROUND
```

### Priority Guidelines

**0 (Critical)**: Safety monitors, emergency stops, fault detection

**10 (High)**: Control loops, actuator commands, real-time feedback

**50 (Normal)**: Sensor processing, state estimation, path planning

**80 (Low)**: Non-critical computation, filtering, analysis

**100 (Background)**: Logging, monitoring, diagnostics, data recording

**Custom Values**: Use any value between 0-255 for fine-grained priority control in complex systems

## Creating Nodes

### Manual Implementation

```rust
use horus::prelude::*;

struct SensorNode {
    data_pub: Hub<f32>,
}

impl SensorNode {
    fn new() -> Result<Self> {
        Ok(Self {
            data_pub: Hub::new("sensor_data")?,
        })
    }
}

impl Node for SensorNode {
    fn name(&self) -> &'static str {
        "SensorNode"
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        let data = 42.0; // Read sensor
        self.data_pub.send(data, &mut ctx).ok();
    }
}
```

### Using the node! Macro

The `node!` macro eliminates boilerplate:

```rust
use horus::prelude::*;

node! {
    name: SensorNode,
    publishers: [sensor_data: f32],

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        let data = 42.0;
        self.sensor_data.send(data, &mut ctx).ok();
    }
}
```

The macro generates:
- Struct definition with Hub fields
- Node trait implementation
- Constructor function
- Topic metadata methods

## Node Communication Patterns

### Publisher Pattern

```rust
struct Publisher {
    data_pub: Hub<f32>,
}

impl Node for Publisher {
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        let data = self.generate_data();
        self.data_pub.send(data, &mut ctx).ok();
    }
}
```

### Subscriber Pattern

```rust
struct Subscriber {
    data_sub: Hub<f32>,
}

impl Node for Subscriber {
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        if let Some(data) = self.data_sub.recv(&mut ctx) {
            self.process(data);
        }
    }
}
```

### Pipeline Pattern

```rust
struct Filter {
    input_sub: Hub<f32>,
    output_pub: Hub<f32>,
}

impl Node for Filter {
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        if let Some(input) = self.input_sub.recv(&mut ctx) {
            let output = input * 2.0;
            self.output_pub.send(output, &mut ctx).ok();
        }
    }
}
```

### Aggregator Pattern

```rust
struct Aggregator {
    input_a: Hub<f32>,
    input_b: Hub<f32>,
    output_pub: Hub<f32>,
}

impl Node for Aggregator {
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        if let (Some(a), Some(b)) = (self.input_a.recv(&mut ctx), self.input_b.recv(&mut ctx)) {
            let result = a + b;
            self.output_pub.send(result, &mut ctx).ok();
        }
    }
}
```

## Best Practices

### Keep tick() Fast

The tick method should complete quickly (ideally &lt;1ms):

```rust
// GOOD: Fast computation
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    let result = self.compute_quickly();
    self.pub.send(result, &mut ctx).ok();
}

// BAD: Blocking I/O
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    let data = std::fs::read_to_string("file.txt").unwrap(); // Blocks!
    // ...
}
```

For slow operations, use async tasks or separate threads initialized in `init()`.

### Initialize in init()

Pre-allocate resources during initialization:

```rust
fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {
    // Pre-allocate buffer
    self.buffer = vec![0.0; 1000];

    // Open connections
    self.connection = connect_to_device()?;

    Ok(())
}

fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    // Use pre-allocated resources
    self.buffer[0] = 42.0;
}
```

### Clean up in shutdown()

Release resources gracefully:

```rust
fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {
    // Close connections
    self.connection.close();

    // Save state
    self.save_state_to_file()?;

    ctx.log_info("Cleanup complete");
    Ok(())
}
```

### Use Result Types

Return errors from init() and shutdown():

```rust
fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {
    if !self.sensor.is_available() {
        return Err("Sensor not found".into());
    }
    Ok(())
}
```

### Check ctx Before Logging

The context is optional in tick():

```rust
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        ctx.log_info("This is safe");
}
```

### Avoid State in Static Variables

Store state in the node struct, not static variables:

```rust
// GOOD
struct MyNode {
    counter: u32,  // Instance state
}

// BAD
static mut COUNTER: u32 = 0;  // Unsafe global state
```

## Error Handling

### Initialization Errors

```rust
fn init(&mut self, ctx: &mut NodeInfo) -> Result<()> {
    self.device = Device::open().map_err(|e| {
        HorusError::InitializationFailed(format!("Failed to open device: {}", e))
    })?;

    ctx.log_info("Device opened successfully");
    Ok(())
}
```

If init() returns an error, the node transitions to **Error** state and won't run.

### Runtime Errors

Handle errors in tick() without panicking:

```rust
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    match self.data_sub.recv(&mut ctx) {
        Some(data) => self.process(data),
        None => {
            // No data available - this is normal
        }
    }
}
```

### Shutdown Errors

```rust
fn shutdown(&mut self, ctx: &mut NodeInfo) -> Result<()> {
    if let Err(e) = self.device.close() {
        ctx.log_warning(&format!("Failed to close device: {}", e));
        // Continue shutdown anyway
    }
    Ok(())
}
```

## Advanced Topics

### Conditional Execution

Run logic only under certain conditions:

```rust
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    self.tick_count += 1;

    // Execute every 10 ticks
    if self.tick_count % 10 == 0 {
        self.slow_operation();
    }
}
```

### State Machines

Implement complex behavior with state machines:

```rust
enum RobotState {
    Idle,
    Moving,
    Stopped,
}

struct RobotController {
    state: RobotState,
    cmd_sub: Hub<CmdVel>,
}

impl Node for RobotController {
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        match self.state {
            RobotState::Idle => {
                if let Some(cmd) = self.cmd_sub.recv(&mut ctx) {
                    self.state = RobotState::Moving;
                }
            }
            RobotState::Moving => {
                // Execute movement
                if self.is_done() {
                    self.state = RobotState::Stopped;
                }
            }
            RobotState::Stopped => {
                self.state = RobotState::Idle;
            }
        }
    }
}
```

### Multi-Topic Synchronization

Wait for data from multiple topics:

```rust
struct Synchronizer {
    topic_a: Hub<f32>,
    topic_b: Hub<f32>,
    last_a: Option<f32>,
    last_b: Option<f32>,
}

impl Node for Synchronizer {
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Update cached values
        if let Some(a) = self.topic_a.recv(&mut ctx) {
            self.last_a = Some(a);
        }
        if let Some(b) = self.topic_b.recv(&mut ctx) {
            self.last_b = Some(b);
        }

        // Process when both available
        if let (Some(a), Some(b)) = (self.last_a, self.last_b) {
            self.process(a, b);
        }
    }
}
```

## Next Steps

- Learn about [Hub and Pub/Sub](/core-concepts-hub) for inter-node communication
- Understand the [Scheduler](/core-concepts-scheduler) for orchestrating nodes
- Explore [Message Types](/message-types) for standard robotics data
- Read the [API Reference](/api-node) for complete Node trait documentation
