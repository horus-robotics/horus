---
title: C++ Bindings
description: Modern C++ API for HORUS hardware drivers
order: 52
---

# HORUS C++ Bindings

> **⚠️ Under Development**: C++ bindings are currently in alpha and under active development.
>
> - ✓ Basic pub/sub operations work
> - ✓ RAII-based memory management
> - ⚠️ Limited to built-in message types only
> - ⚠️ API may change before v1.0
>
> **For production use, we recommend Rust or Python bindings.**
>
> See [Roadmap](/roadmap) for C++ bindings timeline.

**Modern C++ API** for hardware driver integration - perfect for embedded systems, legacy code, and direct hardware access.

## Why HORUS C++?

- **Hardware-First**: Direct sensor/actuator integration
- **Ultra-Low Latency**: ~400ns IPC (same shared memory as Rust)
- **Modern C++17**: RAII, move semantics, exceptions
- **Type-Safe**: Template-based publishers for message types
- **Zero-Copy**: Direct shared memory access
- **Legacy-Friendly**: Integrate existing C++ drivers seamlessly

---

## Quick Start

### Requirements

- **C++17 compiler** (GCC 7+, Clang 5+)
- **HORUS installed** (`cargo install horus`)
- **Linux** (for shared memory support)

### Minimal Example

```cpp
#include "horus.hpp"
#include <iostream>

int main() {
    try {
        // Initialize HORUS system with RAII
        horus::System system("sensor_node");

        // Create publisher for Twist messages (velocity commands)
        horus::Publisher<Twist> cmd_pub("cmd_vel");

        // Main loop
        while (system.ok()) {
            Twist cmd{};
            cmd.linear = 1.5;    // m/s forward
            cmd.angular = 0.8;   // rad/s turn

            cmd_pub.publish(cmd);

            sleep_ms(100);  // 10 Hz
        }
    } catch (const horus::HorusException& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
```

**Compile and run**:
```bash
# HORUS automatically compiles and runs C++ files
horus run sensor.cpp
```

**That's it!** No manual compilation, no build system needed.

---

## API Reference

### System Initialization

#### `horus::System`

RAII wrapper for HORUS initialization. Automatically calls `shutdown()` on destruction.

```cpp
namespace horus {
    class System {
    public:
        explicit System(const std::string& node_name);
        ~System();  // Automatic cleanup

        bool ok() const;          // Check if running
        void spin_once() const;   // Process one event
        void spin() const;        // Block and process events
    };
}
```

**Example**:
```cpp
horus::System system("my_node");

while (system.ok()) {
    // Your code here
    system.spin_once();
}
// Automatic cleanup when System goes out of scope
```

---

### Publishing

#### `horus::Publisher<T>`

Type-safe publisher for built-in message types.

```cpp
namespace horus {
    template<typename T>
    class Publisher {
    public:
        explicit Publisher(const std::string& topic);

        void publish(const T& msg);      // Publish or throw
        bool try_publish(const T& msg);  // Returns false on failure
    };
}
```

**Supported Message Types**:
- `Twist` - Velocity commands (linear, angular)
- `Pose` - Position and orientation
- `LaserScan` - LiDAR/laser range data
- `Imu` - IMU sensor data
- `Image` - Camera image data

**Example**:
```cpp
horus::Publisher<Twist> cmd_pub("cmd_vel");
horus::Publisher<LaserScan> scan_pub("laser_scan");

Twist cmd{};
cmd.linear = 1.5;
cmd.angular = 0.8;
cmd_pub.publish(cmd);
```

---

### Message Types

#### Twist

Robot velocity commands.

```cpp
struct Twist {
    float linear;   // m/s
    float angular;  // rad/s
};
```

#### LaserScan

LiDAR/laser range finder data.

```cpp
struct LaserScan {
    float* ranges;           // Range measurements (meters)
    float* intensities;      // Intensity values (optional)
    uint32_t count;          // Number of points
    float angle_min;         // Start angle (radians)
    float angle_max;         // End angle (radians)
    float angle_increment;   // Angular step (radians)
    float range_min;         // Minimum range (meters)
    float range_max;         // Maximum range (meters)
    float scan_time;         // Time between scans (seconds)
};
```

#### Imu

IMU sensor data.

```cpp
struct Imu {
    float accel_x, accel_y, accel_z;    // m/s²
    float gyro_x, gyro_y, gyro_z;       // rad/s
    float mag_x, mag_y, mag_z;          // μT (optional)
};
```

---

## Hardware Driver Example

Complete example integrating a LiDAR sensor:

```cpp
#include "horus.hpp"
#include <iostream>
#include <vector>

// Simulated LiDAR driver (replace with real driver SDK)
class LidarDevice {
public:
    LidarDevice(const std::string& port) : port_(port) {
        std::cout << "Opening LiDAR on " << port << std::endl;
        // Initialize hardware here
    }

    bool get_scan(std::vector<float>& ranges) {
        // Read from hardware
        ranges.resize(360);
        // ... hardware read logic ...
        return true;
    }

private:
    std::string port_;
};

int main(int argc, char** argv) {
    try {
        horus::System system("lidar_driver");

        // Create publisher
        horus::Publisher<LaserScan> scan_pub("laser_scan");

        // Open hardware
        std::string port = (argc > 1) ? argv[1] : "/dev/ttyUSB0";
        LidarDevice lidar(port);

        std::cout << "LiDAR driver running at 10Hz" << std::endl;

        // Prepare scan message
        std::vector<float> ranges(360);
        LaserScan scan{};
        scan.ranges = ranges.data();
        scan.count = 360;
        scan.angle_min = 0.0f;
        scan.angle_max = 2.0f * M_PI;
        scan.angle_increment = (2.0f * M_PI) / 360.0f;
        scan.range_min = 0.1f;
        scan.range_max = 10.0f;
        scan.scan_time = 0.1f;

        // Main loop
        while (system.ok()) {
            if (lidar.get_scan(ranges)) {
                scan_pub.publish(scan);
            }

            sleep_ms(100);  // 10 Hz
        }

    } catch (const horus::HorusException& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
```

---

## Multi-Language Support

C++ nodes can communicate with Rust and Python nodes seamlessly via shared memory.

**C++ hardware driver**:
```cpp
horus::Publisher<Twist> cmd_pub("cmd_vel");
Twist cmd{1.5, 0.8};
cmd_pub.publish(cmd);
```

**Python processing node**:
```python
import horus

node = horus.Node(name="controller", subs="cmd_vel")
cmd = node.get("cmd_vel")
print(f"Velocity: {cmd['linear']}, {cmd['angular']}")
```

**Rust control node**:
```rust
let cmd: Twist = hub.recv(ctx);
println!("Velocity: {}, {}", cmd.linear, cmd.angular);
```

All use the same shared memory - **zero serialization overhead!**

---

## Best Practices

### Use RAII

Always use `horus::System` and `horus::Publisher` - they handle cleanup automatically.

```cpp
✓ Good:
horus::System system("node");
horus::Publisher<Twist> pub("topic");
// Automatic cleanup

✗ Bad:
init("node");
auto pub = publisher("topic", MSG_TWIST);
shutdown();  // Easy to forget!
```

### Exception Handling

Always wrap HORUS code in try-catch for robustness.

```cpp
try {
    horus::System system("node");
    // Your code
} catch (const horus::HorusException& e) {
    std::cerr << "HORUS Error: " << e.what() << std::endl;
    return 1;
}
```

### Build and Run

```bash
# Single file
horus run driver.cpp

# Multiple files
horus run driver.cpp utils.cpp

# With dependencies
horus run driver.cpp -lrealsense2
```

---

## Limitations

Current C++ API limitations:

- **Built-in types only**: Can only publish/subscribe to built-in message types (Twist, LaserScan, etc.)
- **No custom types**: For custom message types, use Rust API
- **No subscribers yet**: Subscribe API coming soon (use Rust or Python for now)
- **Linux only**: Shared memory requires POSIX `/dev/shm`

For full flexibility, use [Rust API](/api) or [Python bindings](/python-bindings).

---

## Next Steps

- Check out complete examples in `horus_cpp/examples/`
- See [Architecture](/architecture) for how HORUS works
- Read [Multi-Language](/multi-language) for cross-language communication
- Join discussions: https://github.com/horus-robotics/horus/discussions

**Remember**: HORUS C++ API is designed for **hardware integration** - simple, fast, and direct!
