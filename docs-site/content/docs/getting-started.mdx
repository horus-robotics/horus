---
title: Getting Started
description: High-performance framework for building distributed systems with sub-microsecond IPC
order: 4
---

# Getting Started with HORUS

Welcome to **HORUS** - a high-performance framework for building distributed systems with sub-microsecond inter-process communication.

## What is HORUS?

HORUS is a **framework for building applications with multiple independent components** that need to communicate efficiently. Each component handles one responsibility, and they communicate through ultra-low-latency shared memory.

### Built in Rust

HORUS is written in Rust, which gives you:

- **Speed** - Sub-microsecond communication latency (248ns-437ns)
- **Safety** - Compile-time checks prevent common bugs
- **Clean APIs** - Well-designed interfaces that leverage Rust's type system
- **Reliability** - Production-ready from day one

### Multi-Language Support

Don't know Rust? No problem! HORUS provides production-ready bindings for:

- **Python** - Simple functional API, perfect for prototyping and rapid development
- **Rust** - Full framework power for performance-critical code

**Also available (Alpha):**
- **C++** - Hardware driver integration (basic pub/sub works, see [C++ Bindings](/cpp-bindings) for limitations)

## Why Use HORUS?

### 1. Extremely Fast Communication

**HORUS**: Messages arrive in **312-481 nanoseconds**
**Other frameworks**: Messages take **40,000-100,000 nanoseconds**

**What this means**: Your components can talk to each other 100-270x faster. This matters for:
- Real-time control systems
- High-frequency data processing
- Responsive user interfaces
- Multi-sensor fusion

### 2. Ergonomic APIs

HORUS provides clean, Rust-native APIs:

**Manual Implementation**:
```rust
use horus::prelude::*;

struct SensorNode {
    publisher: Hub<f32>,
}

impl SensorNode {
    fn new() -> Result<Self> {
        Ok(Self {
            publisher: Hub::new("temperature")?,
        })
    }
}

impl Node for SensorNode {
    fn name(&self) -> &'static str { "SensorNode" }

    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        let temp = 25.0; // Read from sensor
        self.publisher.send(temp, ctx).ok();
    }
}
```

**Macro-Based Implementation** (covered in [node! Macro Guide](/node-macro)):
```rust
node! {
    SensorNode {
        pub { temperature: f32 -> "temperature" }
        tick(ctx) {
            self.temperature.send(25.0, ctx).ok();
        }
    }
}
```

### 3. Built-in Developer Tools

HORUS includes everything you need:

```bash
# Create a new project
$ horus new my_project

# Run your application
$ horus run

# Monitor in real-time (separate terminal)
$ horus dashboard
```

The dashboard shows:
- All running nodes
- Message flow between components
- Performance metrics
- Real-time debugging

### 4. Works on Your Hardware

HORUS uses **shared memory** for communication, which means:
- **No network overhead** - Everything runs on the same machine efficiently
- **Zero serialization cost** - Data is shared directly, not copied
- **Predictable performance** - No network jitter or packet loss

Perfect for:
- Embedded Linux systems
- Robot controllers
- Edge computing devices
- Multi-core applications

## Core Concepts

### Nodes

A **Node** is just a component that does one thing. Examples:
- Read data from a sensor
- Process some information
- Control a motor
- Display data on screen

Nodes have a simple lifecycle:
1. **Init** - Start up (optional)
2. **Tick** - Do work repeatedly
3. **Shutdown** - Clean up (optional)

### Topics

A **Topic** is a named channel for sending messages. Think of it like a radio frequency - anyone can broadcast on it, anyone can listen.

```rust
// Node A sends on "temperature"
publisher.send(25.0, ctx);

// Node B receives from "temperature"
if let Some(temp) = subscriber.recv(ctx) {
    println!("Got temperature: {}", temp);
}
```

### Hub

A **Hub** is how you create publishers and subscribers:

```rust
// Create a publisher
let publisher: Hub<f32> = Hub::new("temperature")?;

// Create a subscriber (same topic name)
let subscriber: Hub<f32> = Hub::new("temperature")?;
```

It's that simple! The `Hub` handles all the complexity of shared memory for you.

### Scheduler

The **Scheduler** runs your nodes in order:

```rust
let mut scheduler = Scheduler::new();
scheduler.add(Box::new(SensorNode::new()?), 0, Some(true));
scheduler.add(Box::new(DisplayNode::new()?), 1, Some(true));
scheduler.run()?; // Run forever
```

Numbers are **priorities** (0 = highest). Nodes with priority 0 run first, then priority 1, etc.

## Using Pre-Built Nodes

HORUS includes a library of ready-to-use nodes. Just import and connect with topic names:

```rust
use horus::prelude::*;
use horus_library::{KeyboardInputNode, DifferentialDriveNode};

fn main() -> Result<()> {
    let mut scheduler = Scheduler::new();

    // Create nodes - they auto-connect via topics
    let keyboard = KeyboardInputNode::new();
    let drive = DifferentialDriveNode::new();

    scheduler.add(Box::new(keyboard), 0, Some(true));
    scheduler.add(Box::new(drive), 1, Some(true));

    scheduler.run()?;
    Ok(())
}
```

**That's it!** 7 lines for a keyboard-controlled robot. No XML launch files or manual topic wiring - nodes auto-connect via topic names.

Available nodes: `KeyboardInputNode`, `JoystickInputNode`, `CameraNode`, `LidarNode`, `ImuNode`, `DifferentialDriveNode`, `PidControllerNode`, `EmergencyStopNode`, `SafetyMonitorNode`, and more!

## Quick Example: Temperature Monitor

Or build custom nodes when needed:

```rust
use horus::prelude::*;
use std::time::Duration;

// Node that generates temperature readings
struct TemperatureSensor {
    publisher: Hub<f32>,
    reading: f32,
}

impl TemperatureSensor {
    fn new() -> Result<Self> {
        Ok(Self {
            publisher: Hub::new("temperature")?,
            reading: 20.0,
        })
    }
}

impl Node for TemperatureSensor {
    fn name(&self) -> &'static str { "temp_sensor" }

    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        // Simulate temperature changes
        self.reading += 0.1;
        self.publisher.send(self.reading, ctx).ok();
        std::thread::sleep(Duration::from_secs(1));
    }
}

// Node that displays temperature
struct TemperatureDisplay {
    subscriber: Hub<f32>,
}

impl TemperatureDisplay {
    fn new() -> Result<Self> {
        Ok(Self {
            subscriber: Hub::new("temperature")?,
        })
    }
}

impl Node for TemperatureDisplay {
    fn name(&self) -> &'static str { "temp_display" }

    fn tick(&mut self, ctx: Option<&mut NodeInfo>) {
        if let Some(temp) = self.subscriber.recv(ctx) {
            println!("Current temperature: {:.1}°C", temp);
        }
    }
}

// Main program
fn main() -> Result<()> {
    let mut scheduler = Scheduler::new();

    // Add nodes (sensor has higher priority)
    scheduler.add(Box::new(TemperatureSensor::new()?), 0, Some(true));
    scheduler.add(Box::new(TemperatureDisplay::new()?), 1, Some(true));

    // Run forever (Ctrl+C to stop)
    scheduler.run()?;
    Ok(())
}
```

Run it:
```bash
$ horus run temperature_monitor.rs
Current temperature: 20.1°C
Current temperature: 20.2°C
Current temperature: 20.3°C
```

## What Makes HORUS Different?

### vs Traditional Approaches

**Traditional**: Everything in one big program
- Hard to test individual components
- Changes break everything
- Difficult to reuse code

**HORUS**: Independent nodes
- Test each component separately
- Change one node without affecting others
- Reuse nodes in different projects

### vs Message Queues (RabbitMQ, Kafka)

**Message Queues**: Network-based
- 10-100ms latency
- Complex setup and configuration
- Designed for distributed systems over networks

**HORUS**: Shared memory-based
- 248ns-2.8µs latency (sub-microsecond)
- Minimal configuration required
- Optimized for single-machine, multi-process communication

## Learning Path

** Quick Start** (30 minutes)
1. [Installation](/getting-started/installation) - Install HORUS
2. [Quick Start](/getting-started/quick-start) - Build your first app
3. [CLI Reference](/cli-reference) - Learn the commands

**Core Concepts** (2 hours)
4. [Nodes](/core-concepts-nodes) - Build components
5. [Hub](/core-concepts-hub) - Send and receive messages
6. [Scheduler](/core-concepts-scheduler) - Run your application

**Practical Features** (3 hours)
7. [node! Macro](/node-macro) - Eliminate node boilerplate
8. [message! Macro](/message-macro) - Define custom messages in one line
9. [Message Types](/message-types) - Work with data safely
10. [Dashboard](/dashboard) - Monitor and debug

**Advanced** (When you need it)
11. [Multi-Language](/multi-language) - Python and C++ bindings
12. [Performance](/performance) - Optimize for speed
13. [Examples](/examples) - Real projects

## When to Use HORUS

**Great for:**
- Multi-component applications
- Real-time data processing
- Sensor data fusion
- Control systems
- Parallel processing pipelines
- Distributed applications on one machine

**Not ideal for:**
- Single-script programs (use plain Rust/Python instead)
- Over-the-internet communication (use gRPC/HTTP instead)
- Simple CRUD apps (use web frameworks instead)

## Architecture Overview

```
┌─────────────────────────────────────────┐
│         Your Application                │
├─────────────────────────────────────────┤
│  Node 1    Node 2    Node 3             │
│  [Sensor] [Process] [Display]           │
│                 │                       │
│                 ▼                       │
├─────────────────────────────────────────┤
│         Shared Memory                   │
│           (Topics)                      │
├─────────────────────────────────────────┤
│         HORUS Framework                 │
│  • Hub (Communication)                  │
│  • Scheduler (Execution)                │
│  • Logging (Debugging)                  │
└─────────────────────────────────────────┘
```

## Next Steps

Ready to build with HORUS?

1. **[Install HORUS ](/getting-started/installation)**
   Get up and running in 5 minutes

2. **[Quick Start Tutorial ](/getting-started/quick-start)**
   Build a working application

3. **[See Examples ](/examples)**
   Learn from real projects

**Questions?** Check out the [CLI Reference](/cli-reference) or [Architecture](/architecture) pages.

Let's build something amazing! 
