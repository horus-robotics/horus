---
title: Registry & Marketplace
description: Browse, discover, and publish packages on the HORUS Registry
order: 9
---

# Registry & Marketplace

The HORUS Registry and Marketplace provide a centralized platform for discovering, publishing, and managing robotics packages. Whether you're looking for existing components or sharing your work with the community, the marketplace makes it easy.

## Overview

### What is the Registry?

The **Registry** is the backend infrastructure that:
- Stores and distributes packages
- Manages package metadata and versions
- Handles authentication and authorization
- Provides API endpoints for package operations
- Tracks downloads and usage statistics

### What is the Marketplace?

The **Marketplace** is the web interface that:
- Displays available packages with rich metadata
- Provides search and discovery features
- Shows package documentation (external or built-in)
- Links to source repositories
- Offers package details and version history

## Accessing the Marketplace

### Web Interface

Browse packages at the marketplace URL:

```
http://localhost:3003      # Local development
https://marketplace.horus.dev  # Production (when available)
```

**Features:**
- **Search Bar**: Find packages by name or description
- **Filter Tabs**: Browse by category (Navigation, Vision, Control)
- **Package Cards**: Quick overview with stats
- **Details Page**: Comprehensive package information

### CLI Access

Access registry features directly from the command line:

```bash
# Search packages
horus pkg list sensor

# Get package info
horus pkg info pid-controller

# Install packages
horus pkg install motion-planner
```

## Package Discovery

### Browsing Packages

The marketplace home page displays:

```
─────────────────────────────────────────────────────
              HORUS Package Registry                 
    High-performance robotics packages built for     
                      speed                          
─────────────────────────────────────────────────────

─────────────────────────────────────────────────────
  Search: [$ _________________________________]      
─────────────────────────────────────────────────────

─────────────────────────────────────────────────────
  10 Packages  |  15,432 Downloads  |  8 Publishers  
─────────────────────────────────────────────────────

──────────────────── ────────────────────
 pid-controller    motion-planner                  
 v1.2.0               v2.0.1                       
                                                   
 PID controller       A* path planning             
                                                   
 5,234  ★ 45        3,421  ★ 32                    
                                                   
 [View] [Docs]        [View] [Docs]                
        [Source]             [Source]              
──────────────────── ────────────────────
```

### Search Functionality

**By Name or Description:**
```bash
# In the web interface
Search: "sensor fusion"

# Results show packages matching "sensor" or "fusion"
```

**Filter by Category:**
- All
- Navigation
- Vision
- Control
- Perception
- Drivers
- Utilities

### Package Information

Each package card shows:
- **Name and Version**: Current published version
- **Description**: Brief overview
- **Stats**: Downloads, stars, license
- **Action Buttons**:
  - **View Details**: Full package information
  - **Docs**: Documentation (if available)
  - **Source**: Repository link (if available)

## Package Details

### Viewing Package Details

Click "View Details" on any package to see:

**Package Information:**
```
Name: pid-controller
Version: 1.2.0
Publisher: robotics-lab
License: MIT
Downloads: 5,234
Stars: 45

Description:
Production-ready PID controller with anti-windup and
derivative filtering for robotics applications.

Installation:
$ horus pkg install pid-controller
```

**Available Versions:**
- 1.2.0 (latest)
- 1.1.0
- 1.0.0

**Dependencies:**
- control-utils ^1.0.0

## Documentation Features

### Types of Documentation

HORUS packages support two types of documentation:

#### 1. External Documentation

Link to external documentation hosted elsewhere:

**Examples:**
- GitHub Pages: `https://username.github.io/package-docs`
- ReadTheDocs: `https://package-name.readthedocs.io`
- Custom site: `https://docs.example.com/package`

**How it works:**
- Publisher provides URL during publish
- "Docs" button opens URL in new tab
- Users visit external site for documentation

**Best for:**
- Large documentation sites
- Interactive documentation
- Already hosted documentation

#### 2. Local Documentation (Bundled Markdown)

Include documentation directly in the package:

**Structure:**
```
my-package/
── docs/
   ── README.md           # Main page
   ── getting-started.md  # Installation guide
   ── api.md              # API reference
   ── examples.md         # Usage examples
   ── troubleshooting.md  # Common issues
── src/
── Cargo.toml
```

**How it works:**
- Markdown files bundled with package
- Registry extracts and serves .md files
- Built-in viewer renders markdown
- Supports GitHub Flavored Markdown

**Features:**
- Syntax highlighting
- Navigation sidebar
- Version-specific docs
- Works offline
- No external hosting needed

**Best for:**
- Simple documentation
- Version-specific docs
- Offline-first packages
- Quick setup

### Viewing Documentation

**From Package Card:**
```
────────────────────
 my-package                      
 v1.0.0                          
                                 
 [View] [Docs]      
────────────────────
```

**Local Docs Viewer:**
```
──────────────────────────────────────────────────────
  my-package Documentation                     v1.0.0 
  ← Back to package details                           
─────────────────────────────────────────────────────
 Documentation  # Getting Started                    
                                                     
 • README.md    Install the package:                 
 • getting-     ```bash                              
   started.md   horus pkg install my-package         
 • api.md       ```                                  
 • examples.md                                       
                ## Usage                             
                                                     
                Import and use in your code:         
                ```rust                              
                use my_package::MyNode;              
                ```                                  
─────────────────────────────────────────────────────
```

### Writing Good Documentation

**README.md (Required):**
```markdown
# Package Name

Brief description of what your package does.

## Features

- Feature 1
- Feature 2
- Feature 3

## Installation

```bash
horus pkg install my-package
```

## Quick Start

```rust
use my_package::MyNode;
use horus::prelude::*;

fn main() {
    let node = MyNode::new();
    // Use your node...
}
```

## License

MIT
```

**getting-started.md (Recommended):**
```markdown
# Getting Started

## Prerequisites

- HORUS 0.1.0 or higher
- Rust 1.70+

## Installation

Install via HORUS package manager:

```bash
horus pkg install my-package
```

## Basic Usage

1. Import the package
2. Create a node instance
3. Register with scheduler
4. Run your application

[... detailed steps ...]
```

**api.md (Recommended):**
```markdown
# API Reference

## Structs

### `MyNode`

Main node structure for processing.

```rust
pub struct MyNode {
    pub input: Hub<f64>,
    pub output: Hub<f64>,
}
```

#### Methods

##### `new()`

Creates a new instance.

```rust
pub fn new() -> Self
```

[... more API docs ...]
```

## Source Repository Links

### Why Link Your Repository?

Linking your source repository helps users:
- View source code
- Report issues
- Contribute to development
- Check recent activity
- Star/fork the project

### Supported Platforms

- **GitHub**: `https://github.com/username/repo`
- **GitLab**: `https://gitlab.com/username/repo`
- **Bitbucket**: `https://bitbucket.org/username/repo`
- **Self-hosted Git**: Any public Git URL

### Auto-Detection

The CLI automatically detects your Git remote:

```bash
$ cd my-package
$ git remote -v
origin  git@github.com:username/my-package.git

$ horus pkg publish
# ...
Source Repository
    Auto-detected: https://github.com/username/my-package
   Add source repository? (y/n): y
```

### Manual Configuration

If auto-detection doesn't work:

```bash
Source Repository
   Add source repository? (y/n): y
   Enter source repository URL: https://github.com/username/repo
    Source repository: https://github.com/username/repo
```

## Publishing with Documentation

### Complete Publishing Flow

```bash
$ cd my-sensor-package
$ tree
.
── Cargo.toml
── docs/
   ── README.md
   ── getting-started.md
   ── api.md
   ── examples.md
── src/
    ── lib.rs

$ horus pkg publish

Publishing my-sensor-package v1.0.0...
 Uploaded to registry

Package Metadata (optional)

Documentation
    Found local /docs folder with markdown files
   Add documentation? (y/n): y

   Options:
     1. External URL
     2. Local /docs folder

   Choose (1/2/skip): 2
    Will bundle local /docs folder

Source Repository
    Auto-detected: https://github.com/robotics/my-sensor-package
   Add source repository? (y/n): y
   Use detected URL? (y/n): y
    Source repository: https://github.com/robotics/my-sensor-package

Package metadata updated!
```

### Updating Metadata Later

You can't currently update documentation/source URLs after publishing. To update:

1. Publish a new version with updated metadata
2. Or contact registry administrators

## Registry API

### Direct API Access

For programmatic access:

**List all packages:**
```bash
curl https://marketplace.horus-registry.dev/api/packages
```

**Search packages:**
```bash
curl "https://marketplace.horus-registry.dev/api/packages/search?q=sensor"
```

**Get package info:**
```bash
curl https://marketplace.horus-registry.dev/api/packages/pid-controller
```

**Download package:**
```bash
curl -o pkg.tar.gz \
  https://marketplace.horus-registry.dev/api/packages/pid-controller/1.2.0/download
```

**Get local documentation:**
```bash
curl https://marketplace.horus-registry.dev/api/packages/my-package/1.0.0/docs/README.md
```

### API Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/packages` | GET | List all packages |
| `/api/packages/search?q={query}` | GET | Search packages |
| `/api/packages/{name}` | GET | Get package info |
| `/api/packages/{name}/versions` | GET | List versions |
| `/api/packages/{name}/{version}/download` | GET | Download package |
| `/api/packages/{name}/{version}/docs/{path}` | GET | Get documentation file |
| `/api/packages/{name}/{version}` | DELETE | Unpublish package |
| `/api/packages/{name}/{version}/metadata` | POST | Update metadata |

## Best Practices

### For Package Publishers

**Documentation:**
- Include comprehensive README
- Provide usage examples
- Document all public APIs
- Add troubleshooting section
- Keep docs version-specific

**Source Repository:**
- Always link your repository
- Keep repository public
- Use meaningful commit messages
- Tag releases properly
- Respond to issues

**Package Quality:**
- Write tests
- Add examples
- Use semantic versioning
- Include license file
- Document dependencies

### For Package Users

**Discovery:**
- Browse by category
- Read documentation first
- Check download count
- View source repository
- Look at recent updates

**Installation:**
- Pin specific versions
- Review dependencies
- Test in development first
- Read changelog
- Report issues

## Security & Privacy

### Package Ownership

- Only package owners can unpublish
- Authentication required for publishing
- API keys stored securely
- GitHub OAuth for authentication

### Content Security

- External docs open in new tab with `noopener noreferrer`
- Local docs sandboxed in viewer
- No executable code in markdown
- XSS protection enabled

### Privacy

- Downloads counted anonymously
- No personal data collected
- GitHub username visible on packages
- API keys never exposed

## Troubleshooting

### Documentation Not Showing

**Problem:** "Docs" button doesn't appear

**Solutions:**
1. Check if docs were added during publish
2. Verify docs_url is set in database
3. For local docs, check /docs folder exists
4. Republish package with documentation

### Source Link Broken

**Problem:** Source button links to wrong URL

**Solutions:**
1. Verify Git remote URL: `git remote -v`
2. Ensure URL is publicly accessible
3. Republish with correct URL

### Local Docs Not Rendering

**Problem:** Markdown files show errors

**Solutions:**
1. Ensure files are valid markdown (.md)
2. Check files are in /docs folder
3. Verify markdown syntax
4. Try viewing raw content via API

## Custom Registries

HORUS supports custom registries, allowing organizations to host their own private package repositories. This is useful for:

- **Internal/proprietary packages** - Keep company code private
- **Air-gapped environments** - Operate without internet access
- **Custom package hosting** - Control your own infrastructure
- **Development/testing** - Test registry changes locally

### Using a Custom Registry

Set the `HORUS_REGISTRY_URL` environment variable to point to your custom registry:

```bash
# Temporary (current session only)
export HORUS_REGISTRY_URL=https://registry.company.internal

# Permanent (add to ~/.bashrc or ~/.zshrc)
echo 'export HORUS_REGISTRY_URL=https://registry.company.internal' >> ~/.bashrc
source ~/.bashrc
```

**All HORUS commands automatically use the custom registry:**

```bash
# Install from custom registry
horus pkg install my-internal-package

# Publish to custom registry
horus auth login --github
horus pkg publish

# Search custom registry
horus pkg list sensor

# Freeze/restore environments using custom registry
horus env freeze
horus env restore production.yaml
```

### Creating Your Own Registry

To create a custom HORUS registry, you need to implement a REST API server that supports the required endpoints.

#### Required API Endpoints

**1. Package Download (Public)**
```
GET /api/packages/{name}/{version}/download
```
- Returns: tar.gz file containing the package
- Version can be "latest" for the most recent version
- Used by: `horus pkg install`

**2. Package Upload (Authenticated)**
```
POST /api/packages/upload
Authorization: Bearer {api_key}
Content-Type: multipart/form-data

Form fields:
  - name: string (package name)
  - version: string (semver version)
  - description: string (optional)
  - license: string (default: MIT)
  - package: file (tar.gz archive)
```
- Returns: 200 OK on success
- Returns: 401 Unauthorized if API key is invalid
- Used by: `horus pkg publish`

**3. Package Metadata Update (Authenticated)**
```
POST /api/packages/{name}/{version}/metadata
Authorization: Bearer {api_key}
Content-Type: multipart/form-data

Form fields:
  - docs_url: string (documentation URL)
  - docs_type: string ("external" or "local")
  - source_url: string (repository URL)
  - categories: string (comma-separated)
```
- Returns: 200 OK on success
- Used by: `horus pkg publish` (optional metadata step)

**4. Package Unpublish (Authenticated)**
```
DELETE /api/packages/{name}/{version}
Authorization: Bearer {api_key}
```
- Returns: 200 OK on success
- Returns: 403 Forbidden if not package owner
- Used by: `horus pkg unpublish`

**5. Package Search (Public)**
```
GET /api/packages/search?q={query}
```
- Returns: JSON array of packages matching query
```json
[
  {
    "name": "pid-controller",
    "version": "1.2.0",
    "description": "PID controller for robotics"
  }
]
```
- Used by: `horus pkg list`

**6. Package Versions (Public)**
```
GET /api/packages/{name}/versions
```
- Returns: JSON array of available versions
```json
{
  "versions": ["1.2.0", "1.1.0", "1.0.0"]
}
```
- Used by: Version resolution

**7. Import Resolution (Public, Optional)**
```
GET /api/imports/resolve?import={import_name}&language={language}
```
- Returns: Package name for given import
```json
{
  "package_name": "pid-controller"
}
```
- Used by: Automatic dependency resolution
- Optional: Can return 404 if not supported

**8. Environment Publishing (Authenticated, Optional)**
```
POST /api/environments
Authorization: Bearer {api_key}
Content-Type: application/json

{
  "horus_id": "unique-id",
  "name": "Production Environment",
  "packages": [...],
  "system": {...}
}
```
- Returns: 200 OK on success
- Used by: `horus env freeze` (when pushing to registry)
- Optional: Only needed if supporting environment sharing

**9. Environment Retrieval (Public, Optional)**
```
GET /api/environments/{horus_id}
```
- Returns: Environment manifest JSON
- Used by: `horus env restore {horus_id}`
- Optional: Only needed if supporting environment sharing

#### Package Format

Packages must be tar.gz archives containing:

```
package-name/
├── Cargo.toml           # For Rust packages
├── src/
│   └── lib.rs
├── docs/                # Optional: local documentation
│   ├── README.md
│   └── api.md
└── metadata.json        # Created by CLI during install
```

**Minimal Registry Implementation:**

```python
# example-registry.py - Simple Flask-based registry
from flask import Flask, request, jsonify, send_file
import os
import json

app = Flask(__name__)
PACKAGES_DIR = "./packages"
METADATA_FILE = "./metadata.json"

# Load/save metadata
def load_metadata():
    if os.path.exists(METADATA_FILE):
        with open(METADATA_FILE, 'r') as f:
            return json.load(f)
    return {}

def save_metadata(metadata):
    with open(METADATA_FILE, 'w') as f:
        json.dump(metadata, f, indent=2)

# Download package
@app.route('/api/packages/<name>/<version>/download', methods=['GET'])
def download_package(name, version):
    metadata = load_metadata()

    # Handle "latest" version
    if version == "latest":
        versions = metadata.get(name, {}).get("versions", [])
        if not versions:
            return jsonify({"error": "Package not found"}), 404
        version = versions[0]  # Assume sorted, latest first

    package_path = f"{PACKAGES_DIR}/{name}-{version}.tar.gz"
    if not os.path.exists(package_path):
        return jsonify({"error": "Package not found"}), 404

    return send_file(package_path, mimetype='application/gzip')

# Upload package
@app.route('/api/packages/upload', methods=['POST'])
def upload_package():
    # Verify API key
    auth_header = request.headers.get('Authorization', '')
    if not auth_header.startswith('Bearer '):
        return jsonify({"error": "Unauthorized"}), 401

    api_key = auth_header[7:]  # Remove "Bearer "
    # TODO: Validate api_key against your user database

    # Get form data
    name = request.form.get('name')
    version = request.form.get('version')
    description = request.form.get('description', '')
    license = request.form.get('license', 'MIT')
    package_file = request.files.get('package')

    if not all([name, version, package_file]):
        return jsonify({"error": "Missing required fields"}), 400

    # Save package file
    os.makedirs(PACKAGES_DIR, exist_ok=True)
    package_path = f"{PACKAGES_DIR}/{name}-{version}.tar.gz"
    package_file.save(package_path)

    # Update metadata
    metadata = load_metadata()
    if name not in metadata:
        metadata[name] = {"versions": [], "description": description, "license": license}

    if version not in metadata[name]["versions"]:
        metadata[name]["versions"].insert(0, version)  # Add to front (latest)

    save_metadata(metadata)

    return jsonify({"message": "Package published successfully"}), 200

# Search packages
@app.route('/api/packages/search', methods=['GET'])
def search_packages():
    query = request.args.get('q', '').lower()
    metadata = load_metadata()

    results = []
    for name, info in metadata.items():
        if query in name.lower() or query in info.get('description', '').lower():
            results.append({
                "name": name,
                "version": info["versions"][0] if info["versions"] else "unknown",
                "description": info.get("description")
            })

    return jsonify(results)

# List package versions
@app.route('/api/packages/<name>/versions', methods=['GET'])
def list_versions(name):
    metadata = load_metadata()
    if name not in metadata:
        return jsonify({"error": "Package not found"}), 404

    return jsonify({"versions": metadata[name]["versions"]})

# Delete package
@app.route('/api/packages/<name>/<version>', methods=['DELETE'])
def unpublish_package(name, version):
    # Verify API key
    auth_header = request.headers.get('Authorization', '')
    if not auth_header.startswith('Bearer '):
        return jsonify({"error": "Unauthorized"}), 401

    api_key = auth_header[7:]
    # TODO: Validate api_key and check ownership

    # Remove package file
    package_path = f"{PACKAGES_DIR}/{name}-{version}.tar.gz"
    if os.path.exists(package_path):
        os.remove(package_path)

    # Update metadata
    metadata = load_metadata()
    if name in metadata and version in metadata[name]["versions"]:
        metadata[name]["versions"].remove(version)
        if not metadata[name]["versions"]:
            del metadata[name]  # Remove package if no versions left
        save_metadata(metadata)

    return jsonify({"message": "Package unpublished"}), 200

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
```

**Running the example registry:**

```bash
# Install dependencies
pip install flask

# Run the registry
python example-registry.py

# In another terminal, configure HORUS to use it
export HORUS_REGISTRY_URL=http://localhost:8080

# Test it
horus pkg publish
horus pkg install your-package
```

### Production Registry Considerations

For production use, implement:

**Security:**
- HTTPS/TLS encryption (required for production)
- Secure API key storage (hashed, never plain text)
- User authentication (GitHub OAuth, API keys, etc.)
- Package ownership verification
- Rate limiting to prevent abuse

**Storage:**
- Scalable file storage (S3, Google Cloud Storage, MinIO)
- Database for metadata (PostgreSQL, MySQL, MongoDB)
- Backup and redundancy
- CDN for package downloads

**Features:**
- Package versioning and semver support
- Download statistics and analytics
- Package documentation hosting
- Search indexing for fast queries
- Webhook notifications for new packages

### Example: Docker-based Registry

```dockerfile
# Dockerfile for simple HORUS registry
FROM python:3.11-slim

WORKDIR /app

RUN pip install flask gunicorn

COPY example-registry.py /app/
RUN mkdir -p /app/packages

EXPOSE 8080

CMD ["gunicorn", "-w", "4", "-b", "0.0.0.0:8080", "example-registry:app"]
```

```yaml
# docker-compose.yml
version: '3.8'
services:
  registry:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - ./packages:/app/packages
      - ./metadata.json:/app/metadata.json
    environment:
      - FLASK_ENV=production
```

**Deploy:**

```bash
# Start registry
docker-compose up -d

# Use custom registry
export HORUS_REGISTRY_URL=http://localhost:8080
horus pkg install my-package
```

### Authentication for Custom Registries

Custom registries should implement their own authentication system. The HORUS CLI sends API keys via Bearer token:

```
Authorization: Bearer horus_live_abc123...
```

**Implement authentication in your registry:**

1. User registration/login endpoint
2. API key generation endpoint
3. Validate Bearer tokens on protected endpoints
4. Store API keys securely (hashed)

Users configure authentication by saving to `~/.horus/auth.json`:

```json
{
  "api_key": "your-custom-registry-key"
}
```

Or via environment variable:

```bash
export HORUS_API_KEY=your-custom-registry-key
```

### Testing Your Custom Registry

**Checklist:**

- [ ] Download package: `horus pkg install test-package`
- [ ] Upload package: `horus pkg publish`
- [ ] Search packages: `horus pkg list sensor`
- [ ] List versions: Check `/api/packages/{name}/versions`
- [ ] Update metadata: Publish with docs/source URLs
- [ ] Unpublish: `horus pkg unpublish test-package 1.0.0`
- [ ] Authentication: Test with valid/invalid API keys
- [ ] Error handling: Test 404s, 401s, invalid requests

### Migration from Public Registry

To migrate packages from the public registry to your custom registry:

```bash
# 1. Download packages from public registry
export HORUS_REGISTRY_URL=https://horus-marketplace-api.onrender.com
horus pkg install package1
horus pkg install package2

# 2. Find downloaded packages
ls ~/.horus/cache/

# 3. Re-publish to custom registry
export HORUS_REGISTRY_URL=https://registry.company.internal
cd ~/.horus/cache/package1@1.0.0
horus pkg publish

cd ~/.horus/cache/package2@2.0.0
horus pkg publish
```

## Next Steps

- **[Package Management](/package-management)** - Install and manage packages
- **[Marketplace](/marketplace)** - Discover and publish packages
- **[Authentication](/authentication)** - Set up registry credentials
- **[CLI Reference](/cli-reference)** - Complete command documentation
