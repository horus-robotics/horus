---
title: Link API Reference
description: Complete API reference for the Link SPSC system
order: 412
---

# Link API Reference

The `Link<T>` provides ultra-low latency point-to-point (Single Producer Single Consumer) communication through shared memory.

**When to use Link vs Hub:**
- Use **Link** for: Tight control loops, 1-to-1 communication, critical latency paths
- Use **Hub** for: Broadcasting, multiple subscribers, flexible topologies

**Performance advantage**: Link is ~1.56x faster than Hub (389ns vs 606ns round-trip)

## Creating a Link

### `Link::producer(topic_name)`

Create a Link as a producer (sender).

```rust
pub fn producer(topic: &str) -> Result<Self>
```

**Parameters**:
- `topic`: Name of the link (string)

**Returns**: `Result<Link<T>, HorusError>`

**Example**:
```rust
use horus::prelude::*;

let sensor_output: Link<f32> = Link::producer("sensor_data")?;
```

**Type Constraints**:
- `T` must implement `Clone + Debug + Send + Sync`

### `Link::consumer(topic_name)`

Create a Link as a consumer (receiver).

```rust
pub fn consumer(topic: &str) -> Result<Self>
```

**Parameters**:
- `topic`: Name of the link (must match producer's topic)

**Returns**: `Result<Link<T>, HorusError>`

**Example**:
```rust
use horus::prelude::*;

let sensor_input: Link<f32> = Link::consumer("sensor_data")?;
```

**Design**: Link uses a **single-slot** design - the producer always overwrites with the latest value, and the consumer always reads the latest value. This makes Link perfect for sensor data and control loops where you always want the most recent value.

## Sending Messages (Producer Only)

### `send(msg, ctx)`

Send a message to the consumer (non-blocking).

```rust
pub fn send(&self, msg: T, ctx: Option<&mut NodeInfo>) -> Result<(), T>
```

**Parameters**:
- `msg`: Message to send (moved, then cloned internally)
- `ctx`: Optional NodeInfo for automatic logging

**Returns**:
- `Ok(())`: Message sent successfully (always succeeds for Link)

**Performance**: ~89ns for send operation alone, ~389ns full round-trip

**Example**:
```rust
// Without logging
link.send(42.0, None).ok();

// With automatic logging (recommended)
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    link.send(42.0, ctx).ok();
}
```

**Note**: Link's single-slot design means `send()` always succeeds - it simply overwrites the previous value. This is by design for sensor/control data where you always want the latest value.

## Receiving Messages (Consumer Only)

### `recv(ctx)`

Receive a message from the producer (non-blocking).

```rust
pub fn recv(&self, ctx: Option<&mut NodeInfo>) -> Option<T>
```

**Parameters**:
- `ctx`: Optional NodeInfo for automatic logging

**Returns**:
- `Some(msg)`: New message received (sequence number changed)
- `None`: No new message (already read the current value)

**Performance**: ~300ns receive operation (estimated)

**Example**:
```rust
// Without logging
if let Some(value) = link.recv(None) {
    println!("Received: {}", value);
}

// With automatic logging (recommended)
fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
    if let Some(value) = link.recv(ctx) {
        self.process(value);
    }
}
```

**Best Practices**:
- Always check `recv()` every tick for responsive nodes
- `None` is normal - means no new data since last read
- Messages are cloned when received
- Link skips intermediate values - you only get the latest

## Utility Methods

### `is_producer()`

Check if this Link end is a producer.

```rust
pub fn is_producer(&self) -> bool
```

**Returns**: `true` if producer, `false` if consumer

**Example**:
```rust
if link.is_producer() {
    link.send(data, None).ok();
}
```

### `is_consumer()`

Check if this Link end is a consumer.

```rust
pub fn is_consumer(&self) -> bool
```

**Returns**: `true` if consumer, `false` if producer

**Example**:
```rust
if link.is_consumer() {
    if let Some(data) = link.recv(None) {
        println!("Got: {:?}", data);
    }
}
```

### `role()`

Get the role of this Link end.

```rust
pub fn role(&self) -> LinkRole
```

**Returns**: `LinkRole::Producer` or `LinkRole::Consumer`

**Example**:
```rust
match link.role() {
    LinkRole::Producer => println!("I'm a producer"),
    LinkRole::Consumer => println!("I'm a consumer"),
}
```

### `get_topic_name()`

Get the topic name for this link.

```rust
pub fn get_topic_name(&self) -> &str
```

**Returns**: Topic name as string slice

**Example**:
```rust
println!("Topic: {}", link.get_topic_name());
```

### `has_messages()`

Check if messages are available (consumer only).

```rust
pub fn has_messages(&self) -> bool
```

**Returns**: `true` if new data is available (sequence changed since last read)

**Example**:
```rust
if link.has_messages() {
    let msg = link.recv(None).unwrap();
}
```

### `get_metrics()`

Get performance metrics for this Link.

```rust
pub fn get_metrics(&self) -> LinkMetrics
```

**Returns**: `LinkMetrics` with message counts

**Example**:
```rust
let metrics = link.get_metrics();
println!("Sent: {}, Received: {}", metrics.messages_sent, metrics.messages_received);
```

## Valid Message Types

### Primitives

```rust
Link::<f32>::producer("float")?;
Link::<f64>::producer("double")?;
Link::<i32>::producer("int")?;
Link::<u32>::producer("uint")?;
Link::<bool>::producer("bool")?;
```

### Arrays

```rust
Link::<[f32; 3]>::producer("position")?;
Link::<[u8; 1024]>::producer("buffer")?;
```

### Structs

Must implement `Clone + Debug`:

```rust
#[derive(Clone, Debug)]
struct MotorCommand {
    voltage: f32,
    enable: bool,
}

let cmd_link: Link<MotorCommand> = Link::producer("motor_cmd")?;
```

### Standard Messages

HORUS provides pre-defined message types:

```rust
use horus::prelude::*;
use horus_library::messages::{CmdVel, LaserScan, Imu};

let cmd_link: Link<CmdVel> = Link::producer("cmd_vel")?;
let scan_link: Link<LaserScan> = Link::producer("scan")?;
let imu_link: Link<Imu> = Link::producer("imu")?;
```

## Communication Patterns

> **Note**: Examples below focus on communication patterns. For full working examples, see [Core Concepts: Link](/core-concepts-link) and [Examples](/examples).

### Point-to-Point Control Loop

Typical motor controller with encoder feedback:

```rust
// Motor driver node (produces encoder data, consumes commands)
struct MotorDriver {
    cmd_input: Link<MotorCommand>,      // Consumer
    encoder_output: Link<EncoderData>,  // Producer
}

impl MotorDriver {
    fn new() -> Result<Self> {
        Ok(Self {
            cmd_input: Link::consumer("motor_cmd")?,
            encoder_output: Link::producer("encoder")?,
        })
    }
}

impl Node for MotorDriver {
    fn name(&self) -> &'static str {
        "MotorDriver"
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Receive command
        if let Some(cmd) = self.cmd_input.recv(ctx) {
            self.apply_voltage(cmd.voltage);
        }

        // Send encoder feedback
        let reading = self.read_encoder();
        self.encoder_output.send(reading, ctx).ok();
    }
}

// Controller node (consumes encoder data, produces commands)
struct Controller {
    encoder_input: Link<EncoderData>,   // Consumer
    cmd_output: Link<MotorCommand>,     // Producer
}

impl Controller {
    fn new() -> Result<Self> {
        Ok(Self {
            encoder_input: Link::consumer("encoder")?,
            cmd_output: Link::producer("motor_cmd")?,
        })
    }
}

impl Node for Controller {
    fn name(&self) -> &'static str {
        "Controller"
    }

    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Receive feedback
        if let Some(reading) = self.encoder_input.recv(ctx) {
            // PD control
            let cmd = self.compute_control(reading);

            // Send command
            self.cmd_output.send(cmd, ctx).ok();
        }
    }
}
```

### Sensor Processing Pipeline

Chain processing nodes with minimal latency:

```rust
// Raw sensor -> Preprocessor -> Filter -> Output
struct SensorNode {
    output: Link<RawData>,
}

struct PreprocessorNode {
    input: Link<RawData>,
    output: Link<ProcessedData>,
}

struct FilterNode {
    input: Link<ProcessedData>,
    output: Link<FilteredData>,
}
```

### Bidirectional Communication

Two nodes communicating in both directions:

```rust
struct NodeA {
    to_b: Link<RequestMsg>,
    from_b: Link<ResponseMsg>,
}

struct NodeB {
    from_a: Link<RequestMsg>,
    to_a: Link<ResponseMsg>,
}
```

## Performance Characteristics

### Latency

| Message Size | Link Latency | Hub Latency | Link Advantage |
|--------------|--------------|-------------|----------------|
| 16B (CmdVel) | 389ns | 606ns | **1.56x faster** |
| 304B (IMU) | ~600ns | ~800ns | **1.33x faster** |
| 1.5KB (LaserScan) | ~1.2µs | ~1.8µs | **1.5x faster** |

**Latency breakdown**:
- Send operation: ~89ns
- Atomic ordering: ~50ns
- Receive operation: ~250ns
- Total round-trip: ~389ns

### Comparison with ROS 2

| System | Latency | Speedup |
|--------|---------|---------|
| ROS 2 Intra-process | 50-100µs | **100-250x** |
| ROS 2 Inter-process | 200-500µs | **500-1300x** |
| **HORUS Link** | **0.39µs** | **Baseline** |
| **HORUS Hub** | **0.61µs** | 0.64x |

### When Link Matters

Link's performance advantage is critical for:
- **Control loops &gt;1kHz** (1ms cycle time or faster)
- **Sensor fusion** with high-frequency IMU (100Hz-1kHz)
- **Motor control** with encoder feedback
- **Vision processing** pipelines with frame handoff
- **Real-time planning** with feedback loops

## Best Practices

### Topic Naming

Use descriptive names that indicate the data flow:

```rust
// Good
Link::producer("motor_cmd")?;
Link::producer("encoder_feedback")?;
Link::producer("vision_to_planning")?;

// Bad
Link::producer("data")?;  // Too vague
Link::producer("link1")?; // Not descriptive
```

### Type Safety

Producer and consumer must use the same type:

```rust
// Producer
let producer: Link<f32> = Link::producer("velocity")?;

// Consumer - must match type!
let consumer: Link<f32> = Link::consumer("velocity")?;
```

### Latest Value Semantics

Link uses a **single-slot** design - only the latest value is kept:

```rust
// Producer sends: A, B, C rapidly
producer.send(msg_a, None).ok();
producer.send(msg_b, None).ok();  // Overwrites A
producer.send(msg_c, None).ok();  // Overwrites B

// Consumer only sees: C (the latest)
let msg = consumer.recv(None); // msg_c (A and B were skipped)
```

**This is by design** - perfect for sensors/control where you always want the most recent value, not a queue of old values.

## Common Patterns

### Buffered Consumer

Always maintain last known value:

```rust
struct ControllerNode {
    encoder_input: Link<f32>,
    last_reading: Option<f32>,
}

impl Node for ControllerNode {
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        // Update cache if new message available
        if let Some(reading) = self.encoder_input.recv(ctx) {
            self.last_reading = Some(reading);
        }

        // Always have access to last value
        if let Some(reading) = self.last_reading {
            self.compute_control(reading);
        }
    }
}
```

### Conditional Sending

Only send when value changes significantly:

```rust
struct SensorNode {
    output: Link<f32>,
    last_sent: f32,
}

impl Node for SensorNode {
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        let value = self.read_sensor();

        // Only send if changed by >1%
        if (value - self.last_sent).abs() > 0.01 {
            self.output.send(value, ctx).ok();
            self.last_sent = value;
        }
    }
}
```

### Timeout Detection

Detect when producer stops sending:

```rust
use std::time::{Duration, Instant};

struct WatchdogConsumer {
    input: Link<f32>,
    last_recv: Instant,
}

impl Node for WatchdogConsumer {
    fn tick(&mut self, mut ctx: Option<&mut NodeInfo>) {
        if let Some(value) = self.input.recv(ctx) {
            self.last_recv = Instant::now();
            self.process(value);
        }

        // Check for timeout
        if self.last_recv.elapsed() > Duration::from_millis(100) {
            eprintln!("Warning: No data for 100ms!");
        }
    }
}
```

## Shared Memory Details

### Location

Links store data in `/dev/shm` (Linux shared memory):

```bash
# View HORUS Link shared memory
ls -lh /dev/shm/horus/topics/horus_links_*
```

### Cleanup

HORUS automatically cleans up on graceful shutdown (Ctrl+C).

Manual cleanup:
```bash
rm -f /dev/shm/horus/topics/horus_links_*
```

### Size Calculation

Memory usage per Link (single-slot design):
```
size = header (64 bytes) + sizeof(T)
```

Example:
```rust
// Link<f32> - single slot
// size = 64 + 4 = 68 bytes

// Link<LaserScan> (1.5KB) - single slot
// size = 64 + 1536 = 1600 bytes (~1.6 KB)
```

**Advantage**: Minimal memory footprint compared to buffered queues.

## Troubleshooting

### No Messages Received

**Symptom**: `recv()` always returns `None`

**Checklist**:
1.  Producer and consumer use same topic name?
2.  Producer sending before consumer receiving?
3.  Both using same type `T`?
4.  Producer calling `send()`?

### Type Mismatch

**Symptom**: Compile error when creating consumer

**Fix**: Ensure exact type match:
```rust
// Producer
let p: Link<f32> = Link::producer("data")?;

// Consumer - MUST be f32, not f64!
let c: Link<f32> = Link::consumer("data")?;
```

## Link vs Hub Decision Guide

| Use Link When | Use Hub When |
|---------------|--------------|
| 1-to-1 communication | 1-to-many broadcasting |
| Latency &lt;1µs required | Latency &lt;10µs acceptable |
| Fixed producer/consumer | Dynamic subscribers |
| Control loops &gt;100Hz | General pub/sub |
| Critical path | Non-critical path |

**Example scenarios**:

**Use Link**:
- Motor encoder  Controller (1kHz control loop)
- Camera  Vision processor (30Hz frame processing)
- IMU  State estimator (100Hz sensor fusion)

**Use Hub**:
- Sensor  Multiple loggers/visualizers
- Status updates  Dashboard + Recorder
- Commands  Multiple actuators

## Complete Example

See `examples/link_motor_control.rs` for a full working example of Link in a PD control loop:

```rust
//! Real-world motor control with Link
//!
//! Demonstrates:
//! - Bidirectional communication (commands + feedback)
//! - 1kHz control loop
//! - PD controller implementation
//! - Buffer management

use horus::prelude::*;

// Run with:
// cargo run --example link_motor_control
```

## See Also

- [Hub API Reference](/api-hub) - Many-to-many pub/sub
- [Node API Reference](/api-node) - Node implementation
- [Scheduler API Reference](/api-scheduler) - Node orchestration
- [Benchmarks](/benchmarks) - Performance analysis
