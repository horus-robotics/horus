---
title: Core Concepts
description: Understanding HORUS architecture and IPC backends
order: 1
---

# Core Concepts

HORUS provides multiple IPC backends, each optimized for different use cases. All backends share the same API for seamless switching.

## Architecture Overview

```
┌─────────────────────────────────────────┐
│         HORUS Application               │
├─────────────────────────────────────────┤
│    Publisher/Subscriber API             │
├─────────────────────────────────────────┤
│   Link (SPSC)    Hub (MPMC)             │
├─────────────────────────────────────────┤
│      Shared Memory (/dev/shm)           │
└─────────────────────────────────────────┘
```

## Communication System

### Hub (Topic-Based Pub/Sub)

**Production-Grade Message Passing**

- **Latency**: 312ns-481ns (Link/Hub) for production messages
- **Use case**: All robotics applications - control, sensing, perception
- **Message Types**: CmdVel (~500ns Hub / 312ns Link), IMU (~940ns Hub), LaserScan (~2.2µs Hub), Odometry (~1.1µs Hub)

```rust
use horus::prelude::*;
use horus_library::messages::CmdVel;

// Create publisher/subscriber for any message type
let mut cmd_pub: Hub<CmdVel> = Hub::new("motor/cmd_vel")?;
let mut cmd_sub: Hub<CmdVel> = Hub::new("motor/cmd_vel")?;

// Multiple publishers can send to same topic
let mut pub1: Hub<SensorData> = Hub::new("sensors/imu")?;
let mut pub2: Hub<SensorData> = Hub::new("sensors/imu")?;

// Multiple subscribers receive all messages
let mut sub1: Hub<SensorData> = Hub::new("sensors/imu")?;
let mut sub2: Hub<SensorData> = Hub::new("sensors/imu")?;
```

## Production Performance

**Real Message Latencies** (with serde serialization):

| Message Type | Size | Hub Latency | Link Latency | vs ROS2 |
|--------------|------|-------------|--------------|---------|
| **CmdVel** | 16 B | ~500 ns | 312 ns | **100-320x faster** |
| **IMU** | 304 B | ~940 ns | ~400 ns | **53-250x faster** |
| **LaserScan** | 1.5 KB | ~2.2 µs | ~900 ns | **23-111x faster** |
| **Odometry** | 736 B | ~1.1 µs | ~600 ns | **45-167x faster** |
| **PointCloud (10K)** | 120 KB | ~360 µs | ~120 µs | **14-42x faster** |

See [Benchmarks](/benchmarks) for complete performance analysis.

## Efficient Shared Memory

HORUS uses **shared memory** for fast IPC:

1. Efficient serialization with serde + bincode
2. Shared memory ring buffers for message passing
3. Lock-free operations where possible
4. Fixed-size message structures for safety

```rust
use horus::prelude::*;

// Send complex message types
let cmd = CmdVel::new(1.5, 0.8);  // ~500ns (Hub) / 312ns (Link)
pub.send(cmd, Some(&mut node))?;

if let Some(cmd) = sub.recv() {
    println!("Linear: {}, Angular: {}", cmd.linear, cmd.angular);
}
```

## Message Safety

HORUS messages are **memory-safe** by design:

- Fixed-size arrays instead of `Vec` for shared memory
- `#[repr(C)]` for consistent memory layout
- Serde for safe serialization
- No heap allocation in hot paths

## Next Steps

- [Getting Started](/getting-started) - Build your first HORUS node
- [Benchmarks](/benchmarks) - Production performance analysis
- [Examples](/examples) - Real-world robotics applications
