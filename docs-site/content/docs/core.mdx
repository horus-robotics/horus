---
title: Core Concepts
description: Understanding HORUS architecture and IPC backends
order: 1
---

# Core Concepts

HORUS provides multiple IPC backends, each optimized for different use cases. All backends share the same API for seamless switching.

## Architecture Overview

```
─────────────────────────────────────────
           HORUS Application             
─────────────────────────────────────────
      Publisher/Subscriber API           
─────────────────────────────────────────
     Link (SPSC)    Hub (MPMC)          
─────────────────────────────────────────
        Shared Memory (/dev/shm)         
─────────────────────────────────────────
```

## Communication System

### Hub (Topic-Based Pub/Sub)

**Production-Grade Message Passing**

- **Latency**: 296ns-2.8µs for production messages (with serde)
- **Use case**: All robotics applications - control, sensing, perception
- **Message Types**: CmdVel (296ns), IMU (718ns), LaserScan (1.31µs), Odometry (650ns)

```rust
use horus::prelude::*;
use horus_library::messages::CmdVel;

// Create publisher/subscriber for any message type
let mut cmd_pub: Hub<CmdVel> = Hub::new("motor/cmd_vel")?;
let mut cmd_sub: Hub<CmdVel> = Hub::new("motor/cmd_vel")?;

// Multiple publishers can send to same topic
let mut pub1: Hub<SensorData> = Hub::new("sensors/imu")?;
let mut pub2: Hub<SensorData> = Hub::new("sensors/imu")?;

// Multiple subscribers receive all messages
let mut sub1: Hub<SensorData> = Hub::new("sensors/imu")?;
let mut sub2: Hub<SensorData> = Hub::new("sensors/imu")?;
```

## Production Performance

**Real Message Latencies** (with serde serialization):

| Message Type | Size | Latency | Throughput | vs traditional frameworks |
|--------------|------|---------|------------|---------|
| **CmdVel** | 16 B | 296 ns | 3.4M msg/s | **169x faster** |
| **IMU** | 304 B | 718 ns | 1.4M msg/s | **70x faster** |
| **LaserScan** | 1.5 KB | 1.31 µs | 762K msg/s | **76x faster** |
| **Odometry** | 736 B | 650 ns | 1.5M msg/s | **77x faster** |
| **PointCloud (10K)** | 120 KB | 215 µs | 4.7K msg/s | **23x faster** |

See [Benchmarks](/benchmarks) for complete performance analysis.

## Efficient Shared Memory

HORUS uses **shared memory** for fast IPC:

1. Efficient serialization with serde + bincode
2. Shared memory ring buffers for message passing
3. Lock-free operations where possible
4. Fixed-size message structures for safety

```rust
use horus::prelude::*;

// Send complex message types
let cmd = CmdVel::new(1.5, 0.8);  // 296ns latency
pub.send(cmd, Some(&mut node))?;

if let Some(cmd) = sub.recv() {
    println!("Linear: {}, Angular: {}", cmd.linear, cmd.angular);
}
```

## Message Safety

HORUS messages are **memory-safe** by design:

- Fixed-size arrays instead of `Vec` for shared memory
- `#[repr(C)]` for consistent memory layout
- Serde for safe serialization
- No heap allocation in hot paths

## Next Steps

- [Getting Started](/getting-started) - Build your first HORUS node
- [Benchmarks](/benchmarks) - Production performance analysis
- [Examples](/examples) - Real-world robotics applications
